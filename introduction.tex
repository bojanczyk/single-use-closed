\section{Introduction}
The class of orbit-finite sets is a class of sets that contains all finite sets and some infinite sets, but still shares some properties with the class of finite sets.  The idea, which dates back to Fraenkel Mostowski models of set theory,  is to begin with an infinite set $\atoms$ of \emph{atoms} or \emph{urelements}. We think of the atoms as being names, such as Eve or John, and atoms can only be compared with respect to equality. Intuitively speaking, an  orbit-finite set is a set  that can be constructed using the atoms, such as $\atoms^2$ or $\atoms^*$, subject to the constraint that there are finitely many elements up to  renaming atoms. For example, $\atoms^2$ is orbit-finite because it has two elements up to renaming atoms, namely (John, John) and (John, Eve), while $\atoms^*$ is not orbit-finite, because the length of a sequence is invariant under renaming atoms, and there are infinitely many possible lengths. For a survey on orbit-finite sets, see~\cite{bojanczyk_slightly2018}.

The notion of orbit-finiteness can be seen as an attempt to find an appropriate notion of finiteness for the  nominal sets of Gabbay and Pitts~\cite{PittsAM:nomsns}.  This attempt emerged from the study of computational models such as monoids~\cite{bojanczykNominalMonoids2013} and automata~\cite{bojanczykAutomataTheoryNominal2014} over infinite alphabets. Since automata are also the main use case for the present paper, we illustrate orbit-finiteness using an automaton example. 

\begin{example}[An orbit-finite automaton]\label{ex:first-letter-repeats}
    Let  $L \subseteq \atoms^*$ be the language of  words in which the letter from the first position does not appear again. This language contains John $\cdot$ Mark $\cdot$ Mark $\cdot$ Eve, because John does not reappear, but it does not contain John $\cdot$ Mark $\cdot$ John. To recognise this language, we can use a deterministic automaton, which uses its state to remember the first letter. In this automaton, the input alphabet is $\Sigma = \atoms$ and  the state space is $Q = 1 + 1 + \atoms$. In this state space, there are two special states, namely the initial state and a rejecting error state, and furthermore there is one state for each atom $a \in \atoms$, which represents a situation where the first letter was $a$ but it has not been seen again yet. This state space is orbit-finite, since each of the three components in $Q$ represents a single orbit, with the orbits of the $1$ components being singletons.
\end{example}

Orbit-finite sets have many advantages, which ensure that they are good setting for automata theory, and discrete mathematics in general. For example, an orbit-finite set can be represented in a finite way~\cite{bojanczyk_slightly2018}, which ensures that it becomes meaningful to talk about algorithms that input orbit-finite sets, such as an emptiness check for an automaton. Also, orbit-finite sets are closed under taking disjoint unions and products, which ensures that natural automata constructions, such as the union of two nondeterministic automata or the product of two deterministic automata can be performed.
%  (Closure of orbit-finite sets under products is not immediately obvious, for example the set $\atoms$ has one orbit, but the set $\atoms^3$ has five orbits.)

However, orbit-finite sets do not have all the closure properties of finite sets. Notably missing is the powerset construction, and more generally taking function spaces. For example, if we look at the powerset of $\atoms$, then this powerset will not be orbit-finite, since already the finite subsets give infinitely many orbits (two finite subsets of different size will be in different orbits). The lack of powersets means that one cannot do the subset construction from automata theory, and in particular deterministic and nondeterministic automata are not equivalent. This non-equivalence was known from the early days of automata for infinite alphabets~\cite{kaminskiFiniteMemoryAutomata1994}, and in fact, some decision problems, such as equivalence, are decidable for deterministic automata but undecidable for nondeterministic automata~\cite{nevenFiniteStateMachines2004}. Another construction that fails is converting a deterministic automaton into a monoid~\cite[p.~221]{bojanczykNominalMonoids2013}; this is because function spaces on orbit-finite sets are no longer orbit-finite, as explained in the following example. 

\begin{example}[Failure of the monoid construction]\label{ex:first-letter-repeats-monoid}
    Let us show that the  automaton from Example~\ref{ex:first-letter-repeats} cannot be converted into a monoid. The standard construction would be to define the monoid as the subset $M \subseteq Q \to Q$ of all state transformations, namely the subset generated by individual input letters. 
    Unfortunately, this construction does not work. This is because in order  for  two input words to give the same state transformation, they need to have the set of letters that appear in them. In particular, the corresponding set of set transformations is not orbit-finite, for the same reason as why the finite powerset is not orbit-finite. Not only does the standard construction not work, but also this language is not recognised by any orbit-finite monoid.
\end{example}


An attempt to address this problem was provided in~\cite{stefansk-msc,stefanski-phd,bojanczykstefanski2020}, by using \emph{single-use} functions. The idea, which originates in linear types and linear logic,  is to restrict the functions so that they use each argument at most once. For example, consider the following two functions that input atoms and output Booleans:
\begin{align*}
a \in \atoms \mapsto 
\begin{cases}
    \text{true} & \text{if $a=$ John}\\
    \text{false} & \text{otherwise}
\end{cases}
\qquad \qquad 
a \in \atoms \mapsto 
\begin{cases}
    \text{true} & \text{if $a=$ John or $a = $Eve}\\
    \text{false} & \text{otherwise}
\end{cases}
\end{align*}
The first function is single use, since it compares the input atom to John only, while the second function is not single use, since it requires two comparisons, with John and Eve. Here is another example, which shows that the problems with the monoid construction from Example~\ref{ex:first-letter-repeats-monoid} could be blamed on a violation of the single-use condition.
\begin{example}
    Consider  the transition function of the automaton in Example~\ref{ex:first-letter-repeats}, which inputs a state in $1 + 1 + \atoms$ together with an input letter from $\atoms$, and returns a new state.  This function is not single use. Indeed, if the state is in $\atoms$, then the transition function it for equality with the input letter, but then still keeps the state for future comparisons. 
\end{example}

If one restricts attention to functions that are single use, much of the usual robustness of automata theory is recovered, with deterministic automata being equivalent to monoids, and both being equivalent to two-way deterministic automata~\cite{bojanczykstefanski2020}.

Despite the success of the single-use restriction in solving automata problems, one would ideally prefer a more principled approach, in which instead of defining single-use automata, we would define a more general object, namely single-use sets and functions. Then the definitions of  automata and monoids, as well theorems speaking about them, should arise automatically as a result of suitable closure properties of the sets and functions.

This approach was pursued in~\cite{stefanski-phd}, in which a \emph{category} of orbit-finite sets with single-use functions was proposed. In this corresponding category,  one can represent the set of all of single-use functions between two orbit-finite sets $X$ and $Y$ as a new set, call it $X \Rightarrow Y$, which is  also orbit-finite.  However, as we will see later in this paper, this proposal is not entirely satisfactory, since it fails to account for standard operations that one would like to perform on function spaces, most importantly partial application (currying). Note that partial application is crucial for converting an automaton into a monoid, since the monoid consists of partially applied transition functions, in which the input word is known, but the input state is not. In the language of category theory, the proposal from~\cite{stefanski-phd} failed to be a monoidal closed category.

Let us mention there have been several works using category theory to generalize classical operations on automata, such as the coalgebraic ``generalized powerset construction''~\cite{DBLP:journals/corr/abs-1302-1046}. The closest to the philosophy we exposed above might be the setting introduced by Colcombet and Petrişan~\cite{colcombet2020automata}, where automata in different categories are compared (see~\cite{ColcombetPS21,Aristote24} for applications). Within this setting, Nguy{\~{ê}}n and Pradic have studied some properties of automata over monoidal closed categories~\cite[Sections~1.2.3~and~4.7--4.8]{titoPhD} as part of their research on ``implicit automata''~\cite{IATLC,IATLC2,titoPhD} (cf.~\S\ref{sec:conclusion}).

\paragraph*{Contributions of this paper}

The main contribution of this paper is to propose a notion of single-use sets and functions, which extends the proposal from~\cite{stefanski-phd}, but which is rich enough to have function spaces. More formally, we propose a category, which describes single-use functions on orbit-finite sets, and we prove that this category is symmetric monoidal closed. 
The main idea is to follow the tradition of linear types, and to  distinguish two kinds of products, namely $X \times Y$ and $X \& Y$. Thanks to this distinction, the function space can be typed so that the appropriate operations on functions, namely application and currying, can be implemented in a single-use way. 

Our proposed category is strongly inspired by linear types, and the proof that it is symmetric monoidal closed uses a form of \emph{game semantics}\footnote{In this paper, the game semantics will only appear in the appendix, as they are part of our proofs rather than our main claims. That said, let us point to the lecture notes~\cite{abramsky2013semantics,Hyland1997} as references for the category of ``simple games'' upon which we build. For a recent survey of modern game semantics, see~\cite{ClairambaultHDR}.} -- a tool that we take from programming language theory. However, to the best of our knowledge, it is an original idea to have infinite but orbit-finite base type $\atoms$, and to observe that all constructions in game semantics are consistent with orbit-finiteness. We believe that the resulting category deserves further study, and that it is an interesting and non-trivial example of a category representing ``finite'' objects.

Along the way, we provide examples of how the category can be useful in automata theory. Our main example is converting a deterministic automaton into a monoid, but another example is converting a two-way deterministic automaton into a one-way deterministic automaton. As observed by Hines~\cite[Section 4]{hines2003categorical}, this construction works in traced categories, and we prove that our category is indeed traced. 

An important property of our construction is that it is generic. In fact, instead of having a set that is equipped with equality only, one could use apply the construction to any relational structure, e.g.~real arithmetic $(\mathbb R, +, \times, <)$, as long as the structure is given using relations and not functions. Under further assumptions on the structure, such as having a decidable first-order theory (which holds for real arithmetic) or being $\omega$-categorical (which does not hold for real arithmetic but does hold for the rational numbers with their linear order), further benefits in the resulting single-use category can be derived, such as having an emptiness algorithm for automata. 

Finally, as a minor contribution, we present an alternative solution for the problem of function spaces, which is  to use vector spaces of orbit-finite dimension. This is a minor contribution as far as the present paper is concerned, because the technical tools were developed already in~\cite{bojanczykKM21OrbitFiniteVector}, and the only contribution -- if any -- of this paper is one of perspective, namely framing it as a symmetric monoidal closed category. An advantage of the vector space category is its simplicity, and the fact that it is ``bigger'' in the following sense. The two solutions for function spaces discussed in this paper, namely the single-use solution and the vector space solution, sit on both sides of the classical category of orbit-finite sets, as witnessed by two faithful functors: 
\begin{align*}
\text{single-use orbit-finite sets} 
\to 
\text{orbit-finite sets}
\to 
\text{orbit-finite vector spaces}.
\end{align*}
The generality of vector spaces comes at a price, though. As mentioned before, the single-use construction can be applied to any structure, and the orbit-finite benefits can be derived for all $\omega$-categorical structures (this is the standard assumption in the study of orbit-finiteness). In contrast, the vector space construction is more brittle, and it fails for certain $\omega$-categorical  structures such as the Rado graph.   Another disadvantage of the vector space category is that it is not traced, unlike the single-use category, which precludes the applications to two-way automata. We do not make any claims about the superiority of the single-use category over the vector space category. 
