\documentclass[a4paper,UKenglish,cleveref, autoref, numberwithinsect, thm-restate]{lipics-v2021}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{proof}
\usepackage{graphicx}
\usepackage{xspace}
\usepackage{color} 
\usepackage[all]{xy}
\usepackage{tikz-cd}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage{macros}
\usepackage{MnSymbol}
%\usepackage[shortlabels]{enumitem}
%\usepackage{libertine}
\usepackage{booktabs}
\usepackage{relsize} 
\usepackage{float}


\bibliographystyle{plainurl}% the mandatory bibstyle

\usepackage{todonotes}
\newcommand{\tito}[1]{\todo[inline,color=green!40]{Tito --- #1}}
\newcommand{\rafal}[1]{\todo[color=blue!40]{Rafal --- #1}}



\title{Function spaces for orbit-finite sets} %TODO Please add



\author{Mikołaj Bojańczyk}{University of Warsaw \and \url{https://www.mimuw.edu.pl/~bojan/}}{bojan@mimuw.edu.pl}{}{}%{(Optional) author-specific funding acknowledgements}

\author{Lê Thành Dũng (Tito) Nguy\~{\^{e}}n}{École normale supérieure de Lyon, France \and \url{https://nguyentito.eu/}}{nltd@nguyentito.eu}{https://orcid.org/0000-0002-6900-5577}{Supported by the LABEX MILYON (ANR-10-LABX-0070) of Université de Lyon, within the program ``France 2030'' (ANR-11-IDEX-0007) operated by the French National Research Agency (ANR).}


\author{Rafał Stefański}{University of Warsaw}{rafal.stefanski@mimuw.edu.pl}{}{}%{(Optional) author-specific funding acknowledgements}


\authorrunning{M.~Bojańczyk, L.~T.~D.~Nguy\~{\^{e}}n and R.~Stefański} %TODO mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et al.'

\Copyright{Mikołaj Bojańczyk, Lê Thành Dũng Nguy\~{\^{e}}n and Rafał Stefański} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

\ccsdesc[500]{Theory of computation~Automata}

\keywords{Orbit-finite sets, automata, linear types, game semantics} %TODO mandatory; please add comma-separated list of keywords

\category{Track B: Automata, Logic, Semantics, and Theory of Programming}

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

\acknowledgements{L.~T.~D.\ Nguy\~{\^{e}}n would like to thank Clovis Eberhart and Cécilia Pradic for their ongoing collaboration on ``implicit automata for data words'' (cf.~\cite[\S1.4.4]{titoPhD}), which inspired some ideas in this paper.}%optional

\nolinenumbers %uncomment to disable line numbering
%\hideLIPIcs


%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{Karl Bringmann, Martin Grohe, Gabriele Puppis, and Ola Svensson}
\EventNoEds{4}
\EventLongTitle{51st International Colloquium on Automata, Languages, and Programming (ICALP 2024)}
\EventShortTitle{ICALP 2024}
\EventAcronym{ICALP}
\EventYear{2024}
\EventDate{July 8--12, 2024}
\EventLocation{Tallinn, Estonia}
\EventLogo{}
\SeriesVolume{297}
\ArticleNo{158}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\begin{document}


\newcommand{\loli}{\multimap}


\maketitle 
\begin{abstract}
    Orbit-finite sets are a generalisation of finite sets, and as such support many operations allowed for finite sets, such as pairing, quotienting, or taking subsets. However, they do not support function spaces, i.e.~if $X$ and $Y$ are orbit-finite sets, then the space of finitely supported functions from $X$ to $Y$ is not orbit-finite. We propose a solution to this problem inspired by linear logic.
\end{abstract}

\section{Introduction}
The class of orbit-finite sets is a class of sets that contains all finite sets and some infinite sets, but still shares some properties with the class of finite sets.  The idea, which dates back to Fraenkel--Mostowski models of set theory,  is to begin with an infinite set $\atoms$ of \emph{atoms} or \emph{urelements}. We think of the atoms as being names, such as Eve or John, and atoms can only be compared with respect to equality. Intuitively speaking, an  orbit-finite set is a set  that can be constructed using the atoms, such as $\atoms^2$ or $\atoms^*$, subject to the constraint that there are finitely many elements up to  renaming atoms. For example, $\atoms^2$ is orbit-finite because it has two elements up to renaming atoms, namely (John, John) and (John, Eve), while $\atoms^*$ is not orbit-finite, because the length of a sequence is invariant under renaming atoms, and there are infinitely many possible lengths. For a survey on orbit-finite sets, see~\cite{bojanczyk_slightly2018}.

The notion of orbit-finiteness can be seen as an attempt to find an appropriate notion of finiteness for the  nominal sets of Gabbay and Pitts~\cite{PittsAM:nomsns}.  This attempt emerged from the study of computational models such as monoids~\cite{bojanczykNominalMonoids2013} and automata~\cite{bojanczykAutomataTheoryNominal2014} over infinite alphabets. Since automata are also the main use case for the present paper, we illustrate orbit-finiteness using an automaton example. 

\begin{example}[An orbit-finite automaton]\label{ex:first-letter-repeats}
    Let  $L \subseteq \atoms^*$ be the language of  words in which the letter from the first position does not appear again. This language contains John $\cdot$ Mark $\cdot$ Mark $\cdot$ Eve, because John does not reappear, but it does not contain John $\cdot$ Mark $\cdot$ John. To recognize this language, we can use a deterministic automaton, which uses its state to remember the first letter. In this automaton, the input alphabet is $\Sigma = \atoms$ and  the state space is $Q = 1 + 1 + \atoms$. In this state space, there are two special states, namely the initial state and a rejecting error state, and furthermore there is one state for each atom $a \in \atoms$, which represents a situation where the first letter was $a$ but it has not been seen again yet. This state space is infinite; but it is orbit-finite, since each of the three components in $Q$ represents a single orbit, with the orbits of the $1$ components being singletons.\exampleend
\end{example}

Orbit-finite sets have many advantages, which ensure that they are a good setting for automata theory, and discrete mathematics in general. For example, an orbit-finite set can be represented in a finite way~\cite{bojanczyk_slightly2018}, which ensures that it becomes meaningful to talk about algorithms that input orbit-finite sets, such as an emptiness check for an automaton. Also, orbit-finite sets are closed under taking disjoint unions and products, which ensures that natural automata constructions, such as the union of two nondeterministic automata or the product of two deterministic automata can be performed.
%  (Closure of orbit-finite sets under products is not immediately obvious, for example the set $\atoms$ has one orbit, but the set $\atoms^3$ has five orbits.)

However, orbit-finite sets do not have all the closure properties of finite sets. Notably missing is the powerset construction, and more generally taking function spaces. For example, if we look at the powerset of $\atoms$, then this powerset will not be orbit-finite, since already the finite subsets give infinitely many orbits (two finite subsets of different sizes will be in different orbits). The lack of powersets means that one cannot do the subset construction from automata theory, and in particular deterministic and nondeterministic automata are not equivalent. This non-equivalence was known from the early days of automata for infinite alphabets~\cite{kaminskiFiniteMemoryAutomata1994}, and in fact, some decision problems, such as equivalence, are decidable for deterministic automata but undecidable for nondeterministic automata~\cite{nevenFiniteStateMachines2004}. Another construction that fails is converting a deterministic automaton into a monoid~\cite[p.~221]{bojanczykNominalMonoids2013}; this is because function spaces on orbit-finite sets are no longer orbit-finite, as explained in the following example. 

\begin{example}[Failure of the monoid construction]\label{ex:first-letter-repeats-monoid}
    Let us show that the  automaton from Example~\ref{ex:first-letter-repeats} cannot be converted into a monoid. The standard construction would be to define the monoid as the subset $M \subseteq Q \to Q$ of all state transformations, namely the subset generated by individual input letters. 
    Unfortunately, this construction does not work. This is because in order  for  two input words to give the same state transformation, they need to have the same set of letters that appear in them. In particular, the corresponding set of set transformations is not orbit-finite, for the same reason as why the finite powerset is not orbit-finite. Not only does the standard construction not work, but also this language is not recognized by any orbit-finite monoid.\exampleend
\end{example}


An attempt to address this problem was provided in~\cite{stefansk-msc,stefanski-phd,bojanczykstefanski2020}, by using \emph{single-use} functions. The idea, which originates in linear types and linear logic,  is to restrict the functions so that they use each argument at most once. For example, consider the following two functions that input atoms and output Booleans:
\begin{align*}
a \in \atoms \mapsto 
\begin{cases}
    \text{true} & \text{if $a=$ John}\\
    \text{false} & \text{otherwise}
\end{cases}
\qquad \qquad 
a \in \atoms \mapsto 
\begin{cases}
    \text{true} & \text{if $a=$ John or $a = $Eve}\\
    \text{false} & \text{otherwise}
\end{cases}
\end{align*}
Intuitively, the first function is single-use, since it compares the input atom to John only, while the second function is not single-use, since it requires two comparisons, with John and Eve. Here is another example, which shows that the problems with the monoid construction from Example~\ref{ex:first-letter-repeats-monoid} could be blamed on a violation of the single-use condition.
\begin{example}
    Consider  the transition function of the automaton in Example~\ref{ex:first-letter-repeats}, which inputs a state in $1 + 1 + \atoms$ together with an input letter from $\atoms$, and returns a new state.  This function is not single use. Indeed, if the state is in $\atoms$, then the transition function compares it for equality with the input letter; but if the comparison returns true, another copy of the old state must be kept as the new state for future comparisons. \exampleend
\end{example}

If one restricts attention to functions that are single-use, much of the usual robustness of automata theory is recovered, with deterministic automata being equivalent to monoids, and both being equivalent to two-way deterministic automata~\cite{bojanczykstefanski2020}.

Despite the success of the single-use restriction in solving automata problems, one would ideally prefer a more principled approach, in which instead of defining single-use automata, we would define a more general object, namely single-use sets and functions. Then the definitions of  automata and monoids, as well theorems speaking about them, should arise automatically as a result of suitable closure properties of the sets and functions.

This approach was pursued in~\cite{stefanski-phd}, in which a \emph{category} of orbit-finite sets with single-use functions was proposed. In this corresponding category,  one can represent the set of all single-use functions between two orbit-finite sets $X$ and $Y$ as a new set, call it $X \Rightarrow Y$, which is  also orbit-finite.  However, as we will see later in this paper, this proposal is not entirely satisfactory, since it fails to account for standard operations that one would like to perform on function spaces, most importantly partial application (currying). In the language of category theory, the proposal from~\cite{stefanski-phd} failed to be a monoidal closed category.


 \subparagraph{Contributions of this paper.}
 The main contribution of this paper is to propose a notion of single-use sets and functions, which extends the proposal from~\cite{stefanski-phd}, but which is rich enough to be closed under taking function spaces. More formally, we propose a category of single-use functions between orbit-finite sets equipped with additional metadata, and we prove that a suitable quotient of this category is symmetric monoidal closed (\Cref{thm:quotient-closed}).

The main idea is to follow the tradition of linear types, and to  distinguish two kinds of products, namely $X \otimes Y$ and $X \& Y$. Thanks to this distinction, the function space can be built so that the appropriate operations on functions, namely application and currying, can be implemented in a single-use way.

Our proposed category is strongly inspired by linear types, and the proof that it admits function spaces uses a form of \emph{game semantics} -- a tool that we take from programming language theory. However, as far as we know, it is an original idea to have an infinite but orbit-finite base type $\atoms$, and to observe that all constructions in game semantics are consistent with orbit-finiteness. We believe that the resulting category deserves further study, and that it is an interesting and non-trivial example of a category representing ``finite'' objects.

Some further adjacent developments -- such as an alternative solution to the problem of function spaces, using vector spaces of orbit-finite dimension -- are presented in \Cref{sec:further-topics}.

\section{Sets with atoms}
We begin  with  a brief introduction to orbit-finite sets. For a more detailed treatment, see~\cite{bojanczyk_slightly2018}.

Fix for the rest of this paper a countably infinite set $\atoms$, whose elements will be called atoms.  We assume that $\atoms$ has no other structure except for equality; we will only be interested in notions which are \emph{equivariant}, i.e.~invariant under renaming atoms. For example, $\atoms$ has only two equivariant subsets, namely the empty and full subsets. On the other hand, the set $\atoms^2$ has four equivariant subsets ($\emptyset$, $\atoms^2$, the diagonal and its complement). In order to meaningfully speak about equivariant subsets, we must be able to have an action of atom renamings on the set, as formalized in the following definition. The finite support condition is a technical condition that ensures that the action is well-behaved; it dates back to the work of Fraenkel and Mostowski, and is explained in the survey texts~\cite{PittsAM:nomsns,bojanczyk_slightly2018}.

\begin{definition}
    A \emph{set with atoms} is a set $X$, equipped with an action of the group of atom renamings, subject to the following \emph{finite support condition:} for every $x \in X$ there is a finite set of atoms, such that if an atom renaming $\pi$ fixes all atoms in the set, then it also fixes $x$.
\end{definition}

The idea is that a set with atoms is any kind of object that deals with atoms, such as the set $\atoms^*$ of all words over the alphabet $\atoms$, or the family of finite subsets of $\atoms$. Among such objects, we will be interested in those which are ``finite''. This will be formalized by  saying that there are  finitely many orbits, as described below.
Define the \emph{orbit} of an element $x$ in a set with atoms to be the elements that can be obtained from $x$ by applying some atom renaming. For example, in the set $\atoms^2$,  the orbit of (John, Eve)   contains  (Mark, John), but it does not contain (John, John). The orbits form a partition of a set with atoms. 

\begin{definition}
    A set with atoms is called \emph{orbit-finite} if it has finitely many orbits. 
\end{definition}

Typical examples of orbit-finite sets are polynomial expressions such as $\atoms^4 + \atoms^3 + \atoms^3 + 1$. Here, $1$ represents the set of zero-length sequences; this set has a unique element which is its own orbit.  For  example,  $\atoms^3$ has five orbits, because there are five possible ways of choosing a pattern of equalities in a sequence of three names. On the other hand,  $\atoms^*$ has infinitely many orbits, since sequences of different lengths are necessarily in different orbits.   The family of finite subsets of $\atoms$  is also  not orbit-finite, because subsets of different sizes are in different orbits. The full powerset $\powerset \atoms$ is not even a legitimate object in our setting, because some of its elements, i.e.~some subsets of $\atoms$, violate the finite support condition.

\subsection{Finiteness of function spaces}
\label{sec:orbit-finite-function-spaces}
As mentioned above, orbit-finite sets can be seen as  a certain generalization of finite sets. They allow some, but not all, operations that can usually be done on finite sets. For example, orbit-finite sets are closed under disjoint unions $X + Y$ and products $X \times Y$.  Another good property is that an orbit-finite set has only finitely many equivariant subsets (an equivariant subset is one that is invariant under the action of atom permutations). This is because an equivariant subset is a union of some of the finitely many orbits. This accounts for some of the good computational properties of orbit-finite sets.

If $X$ and $Y$ are orbit-finite sets, the set of equivariant functions $X \to Y$ is always literally finite, because it is an equivariant subset of $X\times Y$. However, as we have seen in Example~\ref{ex:first-letter-repeats-monoid}, when converting an automaton to a monoid, we want to use \emph{partially applied} transition functions, which are in general not equivariant. But they are \emph{finitely supported}, i.e.~invariant under all atom renamings that fix some finite set of atoms that depends only on the function.
The issue is that the \emph{finitely supported function space} from $X$ to $Y$ is not orbit-finite.

\begin{example}\label{ex:atoms-to-atoms}
    Consider the space of finitely supported functions of type $\atoms \to \atoms$. For example, the function below is finitely supported, because it is invariant under all atom renamings that fix Mark, John, Eve and Bill:
    \begin{align*}
    f(a) = \begin{cases}
        \text{Mark} & \text{if $a \in \set{\text{John, Eve, Bill}}$} \\
        a & \text{otherwise}
    \end{cases}
    \end{align*}
    If $\pi$ is the atom renaming that swaps Mark with Adam, then applying it to the function $f$ defined above gives the function $\pi(f)$ that has the same definition (or source code, if a programming intuition is to be followed), except that Mark is used instead of Adam.

    In the case of $\atoms \to \atoms$, the finitely supported function space is not orbit-finite. Indeed, the condition $a \in \set{\text{John, Eve, Bill}}$ can be replaced by $a \in X$ for any finite set $X \subset \atoms$ of exceptional values, and two choices of $X$ of different cardinalities will give us two functions in different orbits. \exampleend
\end{example}


\section{Single-use sets and functions}
\label{sec:single-use-sets}
The lack of function spaces is the problem addressed in this paper.
 Our solution builds on the idea from~\cite[Section 2.2]{stefanski-phd}, which is to consider only functions that are single-use. This notion, already illustrated intuitively in the introduction, is formalized in \Cref{sec:single-use-functions-over-polynomial-orbit-finite-sets}, where we show how it almost, but not quite, achieves function spaces. Then, in the rest of this section, we show how function spaces can be recovered by using a more refined type system. 

\subsection{Single-use functions over polynomial orbit-finite sets}
\label{sec:single-use-functions-over-polynomial-orbit-finite-sets}

We do not define the single-use functions on all orbit-finite sets, but only a syntactically defined fragment, namely the \emph{polynomial orbit-finite sets}, which are sets that can be generated from $1$ and $\atoms$ using  
 products $\times$ and disjoint unions $+$. Therefore, we will allow orbit-finite sets like $1 + \atoms^2$, but we will not allow orbit-finite sets like 
the set of non-repeating pairs
$\setbuild{(a,b)}{$a \neq b \in \atoms$}$ or the set of unordered pairs $\setbuild{\set{a,b}}{$a \neq b \in \atoms$}$. It is an open problem to find a satisfactory definition of single-use functions on all orbit-finite sets. (A simple hack is to use a quotienting construction, similar to \Cref{sec:quotient-category}, but what we would really like to do is to identify some extra structure in a set, possibly an action of some yet unknown group or semigroup, which enables us to speak about single-use functions.)

Consider two polynomial orbit-finite sets $X$ and $Y$. To define which functions $X \to Y$ are single-use, we use an inductive definition. We begin with certain functions that are considered single-use, such as the equality test of type $\atoms \times \atoms \to 1 + 1$. These functions are called the \emph{prime functions}, and their full list is given in Figure~\ref{fig:prime-morphisms-without-with}. Next, we combine the prime functions into new ones using three combinators. The first, and most important, combinator is  function composition. Then, we have two combinators for the two type constructors: if two functions $f_1 : X_1 \to Y_1$ and $f_2 : X_2 \to Y_2$ are single-use, then the same is true for:
\begin{align*}
    f_1 \times f_2 : X_1 \times X_2 \to Y_1 \times Y_2
    \qquad &
    f_1 + f_2 : X_1 + X_2 \to Y_1 + Y_2 \\
    \scriptstyle  (x_1,x_2) \mapsto (f_1(x_1),f_2(x_2)) 
    \qquad &
    {\scriptstyle \text{left}(x_1) \mapsto \text{left}(f_1(x_1)) 
        \quad 
        \text{right}(x_2) \mapsto \text{right}(f_2(x_2)) }.
\end{align*}

Crucially, the list of prime single-use functions does not contain the copying function $a \in \atoms \mapsto (a,a) \in \atoms^2$. Therefore, an alternative name for the single-use functions is \emph{copyless}. If we added copying, then we would get all finitely supported functions~\cite[Lemma 23]{stefanski-phd}.

\begin{table}[h!]
    \centering
    \begin{tabular}{lll}
        \textbf{Function} & \textbf{Type} & \textbf{Definition} \\ \\
        \emph{Functions about $\atoms$} \\
        equality test & $\atoms \times \atoms \to 1 + 1$ & $a, b \mapsto \text{if } a = b \text{ then true else false}$ \\
        constant $a$ & $1 \to \atoms$ & $x \mapsto a$ \\
        identity & $\atoms \to \atoms$ & $x \mapsto x$ \\
        \\
        \emph{Functions about \(\times\)} \\
        commutativity of $\times$ & $X \times Y \to Y \times X$ & $x \times y \mapsto y \times x$ \\
        first projection & $X \times Y \to X$ & $x \times y \mapsto x$ \\
        second projection & $X \times Y \to Y$ & $x \times y \mapsto y$ \\
        append 1 & $X \to X \times 1$ & $x \mapsto x \times ()$ \\
        associativity of $\times$ & $(X \times Y) \times Z \to X \times (Y \times Z)$ & $(x \times y) \times z \mapsto x \times (y \times z)$ \\ \\
        \emph{Functions about \(+\)} \\
        first co-projection & $X \to X + Y$ & $x \mapsto \text{left}(x)$ \\
        second co-projection & $Y \to X + Y$ & $y \mapsto \text{right}(y)$ \\
        co-diagonal & $X + X \to X$ & $\left\{\begin{tabular}{l}
            $\text{left}(x) \mapsto x$\\
            $\text{right}(x) \mapsto x$
            \end{tabular}\right.$ \\
        commutativity of $+$ & $X + Y \to Y + X$ & $\left\{\begin{tabular}{l}
        $\textrm{left}(x) \mapsto \textrm{right}(x)$\\
        $\textrm{right}(y) \mapsto \textrm{left}(y)$
        \end{tabular}\right.$ \\
        associativity of $+$ & $(X + Y) + Z \to X + (Y + Z)$ & $\left\{
        \begin{tabular}{l}
        $\text{left}(\text{left}(x)) \mapsto \text{left}(x)$\\
        $\text{left}(\text{right}(y)) \mapsto \text{right}(\text{left}(y))$\\
        $\text{right}(z)\mapsto \text{right}(\text{right}(z))$
        \end{tabular}\right.$ \\
        \\
        \emph{Distributivity}
        \\
        $+$ distributes over $\times$ & $X \times (Y + Z) \to (X \times Y) + (X \times Z)$ & $\left\{\begin{tabular}{l}
            $x \times (\text{left}(y)) \mapsto \text{left}(x \times y)$\\
            $x \times (\text{right}(z)) \mapsto \text{right}(x \times z)$
        \end{tabular}\right.$ \\
        \\
    \end{tabular}
    \caption{The prime single-use functions for polynomial orbit-finite sets $X, Y$ and $Z$.}
    \label{fig:prime-morphisms-without-with}
\end{table}





\begin{example}\label{ex:six-compositions}
    Consider function of type $\atoms^3 \to \atoms$ which inputs a triple $(a,b,c)$ of atoms and returns $a$ if $c$ is equal to Mark, and $b$ otherwise. This function is a single-use function. It is obtained by composing the six functions listed below:
\begin{center}
    \begin{tabular}{ll}
        Function & Type after function \\
        \hline
        Append 1. & $ \atoms \times \atoms \times \atoms \times 1$ \\
        Replace added $1$ with Mark using the constant function. & $\atoms \times \atoms \times \atoms \times \atoms$ \\
        Apply the equality test to the last two components. & $ \atoms \times \atoms \times (1+1)$ \\
        Distribute. & $ \atoms \times \atoms \times 1 +   \atoms \times \atoms \times 1$ \\
        Project to first and second components, respectively. & $\atoms + \atoms$ \\
        Co-diagonal & $\atoms$ 
    \end{tabular}
\end{center}
To justify this description, one should also show that the six functions are single-use. Three of the functions, namely append 1, distributivity and co-diagonal are prime functions. The other three are obtained by combining prime functions using the combinators. For example, the equality test is paired, using the combinator for $\times$, with the identity on the remaining two atoms. \exampleend
\end{example}

The design goal of the single-use restriction is to have orbit-finite function spaces. The rough idea is that a single-use function can only use a bounded number of atoms in its source code, which guarantees orbit-finiteness of the function space. 

\begin{example}\label{ex:first-single-use-function-space}
    Consider function of type $\atoms \to 1 + 1$, which can be seen as subsets of the atoms, with $1+1$ representing the Booleans. We will consider two function spaces: the larger space of all finitely supported functions, and the smaller space of single-use functions.
    
    A function in the larger space is any finitely supported subset of the atoms; such subsets are the same as the finite and co-finite subsets. Therefore, the larger function space admits an equivariant bijection with a disjoint union of two copies of the finite powerset $\powerset_{\text{fin}} \atoms$, in particular it is not orbit-finite.
    
    Consider now the smaller single-use function space. There are four possible functions of this kind: (a) always return true; (b) always return false; (c) check for equality with some fixed atom $a$; (d) check for disequality ($\neq$) with some fixed atom $a$.  Therefore,  the set of single-use functions  admits an equivariant bijection with the orbit-finite set $1 + 1 + \atoms + \atoms$.
    \exampleend
\end{example}


The above example shows that the space of single-use functions of some type $X \to Y$ is orbit-finite, and in fact it can be described using a polynomial orbit-finite set. This is true for every choice of polynomial orbit-finite sets $X$ and $Y$, as proved in~\cite[Theorem 5]{stefanski-phd}, and illustrated in the following example. 

\begin{example}\label{ex:decision-tree-types} Assume that the input type $X$ is some power of the atoms $\atoms^k$, and the output type $Y$ does not use atoms, e.g.~it is~$Y = 1 +1$. The assumption on the input type can be made without loss of generality using distributivity, while the assumption on the output type is a proper restriction, but it will allow us to skip some technical details of the general construction while retaining the important intuitions. 
We describe below a type that represents all single-use functions from $\atoms^k$ to $Y$; we shall denote it by $\atoms^k \Rightarrow Y$. Note that $\Rightarrow$ is \emph{not} a primitive type constructor in our grammar of types; it is a notation that stands for the inductive construction below.

This type is defined by  induction on $k$. In the base case of $k=0$ we simply need to give a value from the output type, and therefore $\atoms^0 \Rightarrow Y$ is the same as $Y$. Consider now the induction step of $k > 0$.  
    We observe that a single-use function that inputs $\atoms^k$ must begin with some equality test, and then continue with one of two single-use functions that have fewer arguments (one for the case when the equality test returns true, and one for the other case). This observation leads to the following definition of the type $\atoms^k \Rightarrow Y$:
\begin{align*}
\myunderbrace{ \coprod_{i \in \set{1,\ldots,k}} 
    \atoms \times (\atoms^{k-1} \Rightarrow Y) \times (\atoms^{k-1} \Rightarrow Y)
 }{starts by comparing $i$-th  \\
 coordinate to some constant}  \quad + \quad 
\myunderbrace{\coprod_{i, j \in \set{1,\ldots,k}} (\atoms^{k-2} \to Y) \times (\atoms^{k-2} \to Y)}{
    starts by comparing the \\ 
    $i$-th and $j$-th coordinates}.
\end{align*}
Note that the above representation of the function space is not necessarily unique, i.e.~the same function can be represented in several different ways. For example, the order in which equality tests are performed will matter for the representation, but might not matter for the function. This is not something that we worry about, and we will use function spaces with non-unique representations in the paper, see also \Cref{sec:quotient-category} for how we deal with non-uniqueness. \exampleend
\end{example}


%\subparagraph{Problem with currying.}
Unfortunately, the proposal illustrated in Example~\ref{ex:decision-tree-types} and described in more detail in~\cite{stefanski-phd}  does not give a satisfactory solution to the problem of function spaces. The problem is that the set of representations $X \Rightarrow Y$ should  also support operations on functions. More specifically, we should be able to indicate single-use operations which do the following:
\begin{description}
    \item[evaluation:] a single-use function from $(X \Rightarrow Y) \times X$ to $Y$ which inputs a representation of a function and applies it to an argument;
    \item[composition:] a function from $(X \Rightarrow Y) \times (Y \Rightarrow Z)$ to $(X \Rightarrow Z)$ which inputs the representations of two functions and returns a representation of their composition.
    \item[currying:] for each single-use function from  $ X \times Y $ to $Z$, there should be a single-use function from $X$ to $Y \Rightarrow Z$ which inputs a first argument and returns a representation of the  partially applied function;
\end{description}
Only in the presence of all of these operations can we speak of a function space, and the corresponding category can be called closed. (Composition can be obtained through evaluation and currying, so the essential operations are evaluation and currying.) The following example shows that the currying operation is not single-use, and therefore the space of single-use functions as defined in this section is not closed.


\begin{example}\label{ex:currying-not-single-use}
    Consider  the single-use function
    \begin{align*}
    f : \atoms \times \atoms \to 1 + 1 \qquad (a,b)  
    \mapsto \begin{cases}
        \text{result of test $a = $ Mark} & \text{if } b = \text{Eve} \\
        \text{result of test $a = $ John} & \text{otherwise}.
        \end{cases}
    \end{align*}
The currying of this function, is a new function which  maps a first argument $a \in \atoms$ to the partially applied function $f(a,\_)$. This currying is
\begin{align*}
    a \mapsto \begin{cases}
        b \mapsto b = \text{Eve} & \text{if } a = \text{Mark} \\
        b \mapsto b \neq \text{Eve} & \text{if } a = \text{John} \\
        b \mapsto \text{false} & \text{otherwise}
        \end{cases}
\end{align*}
Recall that in Example~\ref{ex:first-single-use-function-space} we showed that the space of single-use functions of type $\atoms \to 1 + 1$ can be represented as $1 + 1 + \atoms + \atoms$. If we use this representation,  then the currying of the function $f$  is not single-use, because we need to compare the input atom $a$ to two constants, Mark and John. If we use the representation from Example~\ref{ex:decision-tree-types}, then the corresponding type will be $\atoms \otimes (1 + 1)^2$, but the problems with currying will persist. \exampleend
\end{example}

For similar reasons, 
the function space, we proposed above, will also not support function composition, which means that it cannot be used to convert automata into single-use monoids, as we would like to do, since the resulting monoid would need to use function composition as its monoid operation.\footnote{This problem is solved in~\cite{bojanczykstefanski2020} and~\cite{stefanski-phd} in a different way, namely by showing that every orbit-finite monoid necessarily divides a single-use monoid, using a  Krohn-Rhodes construction. However, this construction is difficult and delicate, in particular it does not work for atoms that have more structure than equality alone. In contrast, the proposal that we give in this paper works for other kinds of atoms, as discussed in \Cref{sec:further-topics}. }

To solve the problems above, we will introduce a more refined type system, which is based on linear types.  The main idea is to pay more attention to type  in Example~\ref{ex:decision-tree-types}. In that definition, we describe a single-use function by specifying the first equality test that it makes, and then giving two descriptions of the functions that will be used in each of the two possible outcomes of the equality test. The main observation is that these two outcomes are mutually exclusive, and therefore we intend to use only one of the two descriptions. For this reason, we will use a  type constructor $\&$ that comes from linear logic. The intended meaning is  that an object of type $X \& Y$ consists of two objects, but with the ability to use only one of them. Since linear logic uses $\otimes$  for the  product that we have so far denoted by $\times$, we will also follow that convention. Using these two kinds of products, the appropriate type for Example~\ref{ex:decision-tree-types} will now become:
\begin{align*}
\coprod_{i \in \set{1,\ldots,k}} 
        \atoms \otimes ((\atoms^{k-1} \Rightarrow Y) \& (\atoms^{k-1} \Rightarrow Y))
          \quad + \quad 
    \coprod_{i, j \in \set{1,\ldots,k}} (\atoms^{k-2} \to Y) \& (\atoms^{k-2} \to Y).
    \end{align*}
Under this definition, the problems from Example~\ref{ex:currying-not-single-use} will be solved, at least for the particular type considered in that example. However, by introducing a new type constructor, we will have to redefine the single-use functions, and then we will have to give a representation of functions that allow this new type constructor, without incurring the need to add any other new type constructors. This is the subject of the next section.

\subsection{Linear types and single-use functions on them}
\label{sec:linear-types-and-single-use-functions}
As mentioned above, to solve the problems with single-use function spaces, we will consider a type system with two kinds of products, as in the following definition.
\begin{definition}[Linear types]\label{def:datatypes}
    A \emph{linear type} is any expression constructed from the atomic types $1$ and $\atoms$ using three\footnote{We set up our type system without using the multiplicative disjunction $\rotatebox[origin=c]{180}{\&}$ of linear logic -- morally, we take our inspiration from intuitionistic linear logic, rather than classical linear logic.} binary type constructors $+, \&$ and $\otimes$.
\end{definition}
In our linear types, it is only the products that are differentiated, while  $+$ comes in only one version. 
    Here is the intuitive explanation of the difference between the two kinds of products, following Girard~\cite[p.~2]{girard1995advances}. Having a pair $x \otimes y$ is like having the ability of using both components $x$ and $y$. On the other hand, having a pair $x \& y$ is like having the ability to use one of the two components, at our choice, but not both at once. For example, the input type of the equality test will be $\atoms \otimes \atoms$ not $\atoms \& \atoms$, since the test will need to consume both arguments. This intuition can only go so far; for example, it is not entirely clear what ``our choice'' means. We revisit this intuition in  the appendix, where game semantics will be used to indicate who makes which choices. 



We think of each linear type $X$ as representing a set $\sem X$, as defined below:
\begin{align*}
    \qquad \sem{1} = 1
\quad 
\sem{\atoms} = \atoms 
\quad 
\sem{X+Y} = \sem X + \sem Y 
\quad 
\sem{X \otimes Y} =
\sem{X \& Y} = \sem X \times \sem Y.
\end{align*}
All sets that arise in this way will be polynomial orbit-finite sets.
Note that the two kinds of product represent the same set, namely the set of pairs in the usual set-theoretic sense. 
However, the two type constructors will be  different, because different functions will be allowed to operate on them. As the expression goes, ``the proof of the pudding is in the eating''; in this case the pudding is the types and the eating is the functions.  

As we did in Section~\ref{sec:single-use-functions-over-polynomial-orbit-finite-sets}, the single-use functions will be defined in terms of prime functions and combinators. The combinators are the same, except that instead of $f_1 \times f_2$ we now have two ways of pairing functions, using $\otimes$ and $\&$. The prime functions are inherited from the previous system, with $\times$ understood as $\otimes$, together with a few new functions for $\&$, as described in Table~\ref{fig:prime-morphisms-with-with}. This is summarized in the following definition.



\begin{definition}[Single-use functions] The class of single-use functions is the least class of functions with the following properties:
    \begin{enumerate}
        \item It contains the functions from Tables~\ref{fig:prime-morphisms-without-with} and~\ref{fig:prime-morphisms-with-with}, with $\times$ in Table~\ref{fig:prime-morphisms-without-with} understood as $\otimes$;
        \item It is closed under composition, as well as under combining functions using  $+$, $\otimes$ and $\&$. 
    \end{enumerate}
\end{definition}




\begin{table}[h!]
    \centering
    \begin{tabular}{lll}
        \textbf{Function} & \textbf{Type} & \textbf{Definition} \\ \\
        diagonal  & $X \to X \& X$ & $x \mapsto x \& x$ \\
        first projection & $X \& Y \to X$ & $x \& y \mapsto x$ \\
        second projection & $X \& Y \to Y$ & $x \& y \mapsto y$ \\
        $\&$ distributes over $\otimes$ & $X \otimes (Y \& Z) \to (X \otimes Y) \& (X \otimes Z)$ & $x \otimes (y \& z) \mapsto (x \otimes y) \& (x \otimes z)$ \\
        $\&$ distributes over $+$ & $X + (Y \& Z) \to (X \& Y) + (X \& Z)$ & $\left\{\begin{tabular}{l}
        $x \& \text{left}(y) \mapsto \text{left}(x \& y)$\\
        $x \& \text{right}(z) \mapsto \text{right}(x \& z)$
        \end{tabular}\right.$ \\ \\ 
    \end{tabular}
    \caption{Prime single-use functions that involve $\&$.}
    \label{fig:prime-morphisms-with-with}
\end{table}


   


Formally speaking, a single-use function consists of an input linear type $X$, an output linear type $Y$, and a function between the sets $\sem X$ and $\sem Y$ that is generated using the prime functions and combinators from the above definition.  As was the case in Section~\ref{sec:single-use-functions-over-polynomial-orbit-finite-sets}, all single-use functions are  finitely supported.  Therefore, one can think of the single-use functions of type $X \to Y$ as being a subset of the set of all finitely supported functions from $\sem X$ to $\sem Y$. This subset is strict: as we will see, the space of single-use functions will be orbit-finite, unlike the space of all finitely supported functions. We will be thinking of the single-use functions as a category.




\begin{definition}[Category of single-use sets]\label{def:single-use-category}
    The category of single-use sets is:
    \begin{enumerate}
        \item The objects are linear types, as per Definition~\ref{def:datatypes}.
        \item Morphisms between types $X$ and $Y$ are single-use functions from $\sem X$ to $\sem Y$.
    \end{enumerate}
\end{definition}

In the very definition of the above category, there is a faithful functor to the category of  orbit-finite sets with finitely supported functions. This functor maps objects $X$ to their underlying sets $\sem X$, which are orbit-finite sets, and it maps morphisms to the corresponding functions. The functions seen to be finitely supported, and the functor is faithful  by definition, since the morphisms in Definition~\ref{def:single-use-category} are defined to be single-use functions. 



% We use the name \emph{single-use morphisms} for morphisms of the above category. A single-use morphism is the same as a single-use function, together with the information about the types between which it is a morphism. For example, the idenitity function on $\sem{\atoms \& \atoms}$ is the same as the identity function on $\sem{\atoms \otimes \atoms}$, because the two underlying sets are the same, but the corresponding morphisms are different. 
% From now on, instead of talking about single-use functions of type $\sem X \to \sem Y$, we will speak about single-use morphisms of type $X \to Y$.



 
The main technical result of this paper is that the category of single-use sets has function spaces, as stated in the following theorem.  The appropriate product will be $\otimes$, and not $\&$. Since the Cartesian product in our category is $\&$ and not $\otimes$, this means that the result we are targeting is symmetric monoidal closed with respect to $\otimes$, and not Cartesian closed.  For now, our theorem stops a bit short of saying that the category is monoidal closed, since several different elements of the function space might represent the same function; but we will come back to this in \Cref{sec:quotient-category}.

\begin{theorem}\label{thm:single-use-closed}
    Let $V$ and $W$ be objects (i.e.~linear types). There exists an object, denoted by  $\funspace V W$, and a morphism (i.e.~a partial single-use function)
    $\mathrm{eval} : (\funspace V W) \otimes V \to  W$
    with the following property. For every morphism
    $f : {X \otimes V} \to  W$
    there is a (not necessarily unique) morphism
    $h :  X \to (\funspace V W)$
    such that the following diagram commutes:
    \[
    \begin{tikzcd}
    X \otimes V 
    \arrow[r,"h \otimes id"]
    \arrow[dr,"f"']
    &
    (\funspace V W) \otimes V
    \arrow[d,"\mathrm{eval}"] \\
    &
    W
    \end{tikzcd}
    \]
\end{theorem}

The above theorem is the main technical contribution of this paper. The difficulty in its proof is finding a representation of the single-use  functions that is rich enough to capture all functions, but simple enough to be described by a linear type (in particular, the corresponding set will be orbit-finite). In  Section~\ref{sec:single-use-functions-over-polynomial-orbit-finite-sets}, when the types did not have $\&$, we could pull off a relatively simple construction, which was possible mainly due to the strong distributivity rules that allowed converting each type into a normal like $\atoms^{n_1} + \cdots + \atoms^{n_\ell}$. In the presence of $\&$, the distributivity rules are not as strong, and the way in which a single-use program can interact with its input is rather subtle. 
Our solution, and the technical core of this paper, is to use game semantics, appropriately extended to describe the type $\atoms$ and the operations on it that are allowed. This solution is presented in \Cref{sec:game-semantics}.

\section{A quotient construction}
\label{sec:quotient-category}
A drawback of Theorem~\ref{thm:single-use-closed} is that the function space $\funspace V W$ can contain different representations of the same function; this will mean that currying is not unique. To overcome this issue, we use a simple quotient construction. 
Define a \emph{partial equivalence relation} to be a relation that is symmetric and transitive, but not necessarily reflexive.  This is the same as (complete) equivalence relation on some subset. We will use a partial equivalence on the function space $X \Rightarrow Y$ to: (1)
 remove objects that do not represent any morphism; (2) identify two objects if they represent the same morphism. After such a quotient, the function space will have unique representations for functions. 

\begin{definition}
    The \emph{quotiented single-use category} is: 
    \begin{itemize}
    \item Objects are pairs (linear type $X$, equivariant partial equivalence relation on $\sem X$);
    \item Morphisms between objects $(X,\sim_X)$ and $(Y,\sim_Y)$ are single-use functions from $\sem X$ to $\sem Y$ such that the domain of the function is contained in the domain of $\sim_X$, and equivalent inputs are mapped to equivalent outputs.
    \end{itemize}
\end{definition}

The quotiented single-use category is also equipped with a tensor product $\otimes$ on its objects.
\begin{theorem}\label{thm:quotient-closed}
    The quotiented single-use category, equipped with the tensor product $\otimes$, is a monoidal closed category, i.e.~it satisfies the conclusions of Theorem~\ref{thm:single-use-closed}, but, furthermore, the morphism $h$ is unique.
\end{theorem}

\tito{Amadio--Curien?}

\newcommand{\invar}[1]{#1_{\mathrm{in}}}
\newcommand{\outvar}[1]{#1_{\mathrm{out}}}

\section{Game semantics}
\label{sec:game-semantics}

This section is devoted to the proof of Theorem~\ref{thm:single-use-closed}. To construct the function space $X \Rightarrow Y$, we use game semantics to identify a certain normal form of programs that compute single-use functions. The presentation in this section is self-contained, and does not assume any knowledge of game semantics. We base our notation on~\cite{abramsky2013semantics}.\footnote{Another standard reference for the category of ``simple games'' upon which we build is~\cite{Hyland1997}. For a recent survey of modern game semantics, see~\cite{ClairambaultHDR}.}

Let us begin with a brief motivation for why game semantics will be useful.

While it is intuitively clear which functions should be allowed as single-use for simple types such as $\atoms \to 1+1$ or $\atoms \otimes \atoms \to \atoms + \atoms$, these intuitions start to falter when considering more complex types. How can one show that a function is \emph{not} single-use? If one were to use the definition of single-use functions alone, then one would need to rule out any possibility of constructing the function from the primes using the combinators, including constructions that use composition many times, and with unknown intermediate types. 

This is the reason why we consider game semantics. It will allow us to give  a more principled description of the intuition that pairs of type $X \otimes Y$ can be used on both coordinates, while pairs of type $X + Y$ can be used on a chosen coordinate only. The idea behind game semantics is to give the description in terms of an interaction between two players:
\begin{enumerate}
    \item System, who represents the function (we will identify with this player); and
    \item Environment, who supplies inputs and requests outputs of the function.
\end{enumerate}
One of the intuitions behind the setup is that if a type $X \& Y$ appears in the input of the function, then it is the System who can choose to use $X$ or $Y$, while if the type appears in the output, then it is the Environment who makes the choice. (In this paper, we consider functions of first-order types of the form $X \to Y$, where $X$ and $Y$ are linear types that do not use $\otimes$, and therefore there will be a clear distinction between input and output values.)
Before giving a formal definition of game semantics, we give simple example of the interaction.

\begin{example}\label{ex:amp-otimes-distr}
    Consider the two types 
    \begin{align*}
        X \otimes (Y \& Z) 
        \quad \text{and} \quad
        (X \otimes Y) \& (X \otimes Z).
    \end{align*}
    Among the prime functions in Table~\ref{fig:prime-morphisms-with-with}, we find distributivity in the direction $\rightarrow$, but not in the direction $\leftarrow$. We explain this asymmetry using the interaction between two players System and Enviroment.

    Let us first consider the interaction in the  direction $\rightarrow$. Player Environment begins be requesting an output. Since this output is of type $(X \otimes Y) \& (X \otimes Z)$, this means that Environment can choose to request either of the two types  $X \otimes Y$ and $X \otimes Z$. Suppose that Environment requests $X \otimes Y$. Now player System needs to react, and produce two elements: one of type $X$ and one of type $Y$. Both can be obtained from the input; for the second one player System can choose how to resolve the input $Y \& Z$ to get the appropriate value. 

    Consider now the interaction in the opposite direction $\leftarrow$. As we will see, player System will be unable to react to the behavior of player Environment, which will demonstrate that there is no distributivity in this direction. The problem is that player Environment can begin by requesting an element of type $X$, since the output type is $X \otimes (Y \& Z)$, while still reserving the possibility to request $Y \& Z$ in the future (because the tensor product $\otimes$ means that both output values need to be produced). To produce this element, player System will need  choose one of the two coordinates in the input type $(X \otimes Y) \& (X \otimes Z)$, and any of these two  choices will be premature, since player Environment can then request the opposite choice in the output type.  \exampleend
\end{example}

As illustrated in the above example, we will use a game to describe the possible behaviours of a function, as modelled by behaviours of player System. The game will be played in an arena, which will arise from the type of the function, and will tell us what are the possibilities for the moves of both players.  Here is the  outline the plan for the rest of this section. 
\begin{enumerate}
    \item For every two linear types $X$ and $Y$, we  define an arena, which is a data structure that describes all possible interactions between players Environment and System that can arise when running a  single-use  functions of type $X \to Y$;
    \item In each arena, we will be interested in the strategies of player System, i.e.~the ways in which System reacts to moves of Environment. We will show how such strategies can be interpreted as single-use functions: to a strategy we will assign a single-use function of type $X \to Y$ that is represented by this strategy. This mapping will be partial, i.e.~some ill-behaved strategies will not represent any functions. 
    \item We will show that the  set of strategies in an arena is  large enough to represent all single-use functions, but small enough to be orbit-finite. 
    \item We will then strengthen this: not only is the set of strategies orbit-finite, but it can be equipped with the structure of a linear type, such that both evaluation and Currying will be single-use functions.
\end{enumerate}

The arenas from the first step of the plan will  be defined in two sub-steps. We begin by defining arenas and strategies for functions that do not use the structure of the atoms, i.e. constants and equality tests. This will be a fairly generic definition, almost identical to the classical game semantics for linear logic. Then we will extend the definition to cover the extra structure. 

\subsection{Arenas and strategies without constants and equality tests}
\label{sec:arenas-without-constants-and-equality-tests}

We begin with a simpler version of the game semantics, in which the arenas and strategies will describe functions that are not allowed to perform equality tests, and are not allowed to use constants. These strategies will model functions such as the identity function $\atoms \to \atoms$, which directly passes its input to its output, but they  will not model the equality test $\atoms \otimes \atoms \to 1 + 1$, or the constant functions of type $1 \to \atoms$. The general idea is to use standard game semantics for linear logic, with an extra feature that we call \emph{register operations}. The register operations will be used to model the way in which atoms are passed from the input to output. For example, in the identity function,  Environment will  write the input atom into the register, and then player System will read the output atom from that register. The following definition of an arena is based on the definition from \cite[p.4]{abramsky2013semantics}, slightly
adapted for the context of this paper:
\begin{definition}[Arena] \label{def:arena}
    An \emph{arena} consists of:
    \begin{enumerate}
        \item A set of \emph{moves}, with each move having an assigned owner, who is either ``System'' or ``Environment'', and one of three\footnote{\label{footnote:read-write} In all arenas that we consider, the ``read'' moves will be owned by System and the ``write'' moves will be owned by Environment. Therefore, we could simplify the register operations and have just one, called ``read/write'', whose status is determined by its owner. 
        } register operations, which are ``none'', ``read'', or ``write''.
                \item A set of plays, which a set of finite sequences of moves that is closed under prefixes, and such that in every play, the owner of the first move is Environment, and then the owners alternate between the two players.
    \end{enumerate}
\end{definition}




An arena will correspond to a type. The inhabitants of that type, which will be  functions if the type is a functional type $X \to Y$, will be described by strategies in the arena. Such a strategy tells us how player System should react to the moves of player Environment. Intuitively speaking, in the case of a functional type, a strategy will say how the function reacts to requests in the output type and values in the input type. We will only be talking about strategies for player System, so from now on, all strategies will be for player System. The following definition corresponds to the definition from \cite[p.5]{abramsky2013semantics}:
%unless otherwise stated.
% In the above definition, the operations are a non-standard part of the arenas.  The idea is that the operations modify a memory store which has exactly one register, which contain a single atom or be empty.  A move that has an associated operation that is not ``none'' will be called an \emph{atom move}.


\begin{definition}
    A \emph{strategy}  in an arena  is a subset of plays in the arena, which: 
    \begin{enumerate}
        \item is closed under prefixes;
        \item\label{item:sys-ext} if the strategy contains a play $p$ that ends with a move owned by player System, then it also contains all possible plays  in the arena that extend $p$ with one move of player Environment;
        \item\label{item:env-ext} if the strategy contains a play $p$ that ends with a move owned by player Environment, then it contains exactly one play  in the arena that extends $p$ with one move of player System;
         \item there is some $k$ such that all plays in the strategy have length at most $k$;
        \item every ``read'' move is directly preceded by a ``write'' move (in particular a play cannot begin with ``read''), and every ``write'' move is either the last move, or directly succeeded by a ``read'' move.
    \end{enumerate}
\end{definition}

Conditions \ref{item:sys-ext} and \ref{item:env-ext}, which are standard in game semantics,  guarantee that the strategy only ``ends'' when 
Environment has no moves to play.  Let us now comment on the last two conditions, which are not standard.

The fourth condition is motivated by the idea that we study ``finite'' types,  and there will be no need for unbounded computations. 

The last condition will be called the  \emph{immediate read condition}. It ensures that there is matching between ``read'' and ``write'' moves in plays that do not end with write. Since ``write'' will always be owned by Environment, the immediate read condition will ensure a matching between ``write'' and ``read'' moves.
%in the plays that do not end with a move by player Environment, and such plays will be the most important ones. 

We now show how to associate to each linear type a corresponding arena, and also how to associate an arena to a function type $X \to Y$. This definition will be compositional, i.e.~it will arise through operations on arenas that correspond to the type constructors such as $1$ or $\otimes$. The arenas that we will construct so far will not be our final proposal, since the corresponding strategies will not be able to use constants or perform equality tests. This will be fixed in Section~\ref{sec:arenas-with-constants-and-equality-tests}, where a more complex arena will be defined for function types. Before giving formal definition, we begin with a simple example of the arena for the type $\atoms \to \atoms$.
\begin{example}\label{ex:identity-function-without-equality-tests-and-constants}
    We define an arena for the type $\atoms \to \atoms$. This arena will be rather impoverished, since the  only allowed strategy in it will correspond to the identity function. However, this is consistent with the stage that we are at, where we only consider functions that do not use constants or perform equality tests; for such functions the only possibility is the identity function.

     The arena will describe the following interaction between the two players: Environment  requests an output,  then System requests an input, then Environment grants the input, and finally player System grants the output by forwarding the input grant. 
    The arena is shown in the following picture: 
    \mypic{6}
    The methodology of drawing this picture will become clearer later on, as we define operations on arenas such as $\otimes$. For the moment we describe the arena without caring that it arises as a special case of some general construction. The arena has four moves: 
    \begin{center}
        \begin{tabular}{lll}
         move & owner & register operation \\
            \hline
            request output & Environment & none \\
            request input & System & none \\
            grant input & Environment & write \\
            grant output & System & read 
        \end{tabular}    
    \end{center}
    The set of plays is defined as follows. These are all sequences that begin with a move of player Environment, alternate between players, use each move only once, and have the following condition:  ``grant output'' can only be played after ``request output'', and likewise for ``grant input'' and ``request input''.  

    A quick inspection of the above definition reveals that the arena has a unique maximal play, where the moves are played in the order from the table, and all other plays are prefixes of this maximal play. Because of the uniqueness of responses, the set of plays is also a strategy. As mentioned at the beginning of this example, the strategy describes the identity function.  \exampleend
\end{example}

We hope that the above example explains some intuitions about how arenas describe types and strategies describe functions. We now give a formal definition. As mentioned before, this definition is compositional: we define arenas for the basic types $1$ and $\atoms$, and then we define operations on arenas that correspond to the type constructors  $+$, $\&$, and $\otimes$. We begin with the basic types.


\begin{definition}[Arenas for $1$ and $\atoms$]\label{def:arenas-without-atoms-or-functions} \ 
    \begin{enumerate}
        \item     The arena for the type $1$ is empty: there are no moves, the only play is the empty sequence. 
        \item The arena for type $\atoms$ has two moves, which must be played one after the other: first player Environment makes a move called ``request'' that has no register operation, and then player System responds with  a move called ``grant'' that has register operation ``read''.
    \end{enumerate}
\end{definition}

In the above definition, we only described the behaviour of $\atoms$ when viewed as an output type. To get the input type, where the players are swapped and read is swapped with write, we will use duality, which is another operation on arenas. This operation, together with other operations that correspond to the type constructors, are defined below.   

\begin{definition}[Operations on arenas]\label{def:composition-of-arenas}
    Let  $A$ and $B$ be arenas. We define the following arenas (see also Figure~\ref{fig:arena-constructors}):
        \begin{description}
            \item[$A+B$] The moves in this arena are the disjoint union of the moves of $A$ and $B$, with inherited owners and register operations, plus three extra moves: ``ask'' owned by Environment, and ``left'', ``right'' owned by System. 
            The plays are defined as follows. Player Environment begins with  an ask move, then System responds with a left or right move, and the remaining sequence is a play in the arena $A$ or $B$, depending on whether System chose left or right. 
            \item[$A \& B$] The moves in this arena are the disjoint union of the moves of $A$ and $B$, with inherited owners and register operations, plus three extra moves: ``acknowledge'' owned by System, and ``left'', ``right'' owned by Environment. 
            The plays are defined as follows. Player Environment begins by choosing left or right, then player System responds with an acknowledge move, and the remaining sequence is a play  in the arena $A$ or $B$, depending on whether Environment chose left or right.
            (This construction differs slightly from the one from \cite[Excercise~1.10]{abramsky2013semantics} -- this is because we want to keep it analogous to the construction for $A + B$.)
            \item[$A \otimes B$] The moves in this arena are the disjoint union of the moves of $A$ and $B$, with inherited owners and register operations. A play in this arena is any shuffle of plays in the two arenas $A$ and $B$. (A shuffle of two words is any word obtained by interleaving them, e.g.~shuffles of ``abc'' and ``123'' include ``a1b23c'' and ``12ab3c'').
            By Definition~\ref{def:arenas-without-atoms-or-functions}, we require that the owners of the move alternate in the 
            interleaved sequences. (This construction is based on \cite[p.7]{abramsky2013semantics}.) 
            

            \item[$\bar A$] This is called the dual arena of $A$. The moves and plays are the same as in $A$, except the owners are swapped, and the ``read'' and ``write'' register operations are swapped.
        \end{description} 
\end{definition}

\begin{figure}
The arena $A+ B$:
            \mypic{7}
The arena $A \& B$: 
            \mypic{8}
The arena $A \otimes B$:
            \mypic{9}
    \caption{\label{fig:arena-constructors} Pictures of the operations on arenas. The picture for $\otimes$  is less useful than previous two, since the root node of the tree is not a player, but a node labelled by $\otimes$. The intuition is that the game is played in parallel on both arenas, and therefore a position in it can be visualized as a pair of positions in the two arenas.}
\end{figure}


        
Equipped with the above definitions, we  present our first attempt at assigning arenas to types. In the second item of the following definition, we use the name \emph{library-less}, because our final definition of the arena for a function type, as presented in the next section, will be equipped with an extra feature that will be called a library. 

\begin{definition} Let $X$ and $Y$ be linear types.
    \begin{itemize}
        \item The \emph{arena for  $X$} is defined by inductively applying the constructions from Definition~\ref{def:arenas-without-atoms-or-functions} and Definition~\ref{def:composition-of-arenas} according to the structure of the type.
        \item The \emph{library-less arena for $X \to Y$} is defined to be (dual of arena of $X$) $\otimes$ (arena of $Y$).
    \end{itemize}
\end{definition}

As discussed previously, our notion of arenas does not yet take into account the structure of the atoms, i.e.~the constants and equality tests. This will be fixed in the next section, by modifying the second item in the above definition. On the other hand, the arenas from that first item in the above definition, for linear types without function types, are already in their final form. 

In principle the construction from the second item in the above definition can be nested, and thus used to assign arenas to higher order types that can nest $\to$ with the other type constructors. This is how it is usually done in linear logic. However,  the construction that we will describe in the next section will  be less amenable to nesting, and will use it only  to describe functions between types that do not use $\to$.


 

\begin{example}
    The arena for the identity type $\atoms \to \atoms$ is the same as the arena from Example~\ref{ex:identity-function-without-equality-tests-and-constants}.
\end{example}





\subsection{Arenas and strategies with constants and equality tests}
\label{sec:arenas-with-constants-and-equality-tests}
In the Section~\ref{sec:arenas-without-constants-and-equality-tests}, we described arenas for functions that did not use the structure of the atoms, i.e.~constants and equality tests. We now show how these arenas can be extended to cover this structure. The general idea is to equip the arenas with an extra part, which we call the \emph{library},  that describes the allowed operations on the atoms. (The library as we present it here only contains functions for equality and constants, but in the proof of Theorem~\ref{thm:single-use-automata-relational-structures}, we can use a library that has other relations beyond equality. )



\begin{definition}[The library arena] \label{def:library-arena} The library arena and its parts are defined as follows, see Figure~\ref{fig:library-arenas} for pictures.
    \begin{enumerate}
        \item The \emph{constant choice arena} is the following arena $\atoms+1$ moves:
        first player System chooses an atom, then player Environment plays move with register operation ``write''. 
        \item The \emph{equality test arena} is an arena which the plays are as follows:
    \begin{enumerate}
        \item first player System plays a move with register operation ``read'';
        \item then player Environment plays an move with no register operation;
        \item then player System plays a move with register operation ``read'';
        \item then player Environment plays one of two moves, called $=$ and $\neq$, with no register operation.
    \end{enumerate}
    \item The \emph{library arena} is defined to be an arena that is obtained by applying $\otimes$ to infinitely many copies of the constant choice arena and infinitely many copies of the  equality test arena.
    \end{enumerate}
\end{definition}

\begin{figure}
The constant choice arena:
        \mypic{10}
The equality test arena:
    \mypic{11}
\caption{\label{fig:library-arenas} Pictures of the library arenas.  We use the convention that the register operations are in red, and the names of the moves, which have no other role than to distinguish them, are in black. 
Note that the first move in this arena is owned by System, and we assume in Definition~\ref{def:arena} that the first move is owned by Environment. This is because this arena, like all arenas in Definition~\ref{def:library-arena}, is not intended to be a stand-alone arena, but only as part of the bigger arena from Definition~\ref{def:arena-for-function-type} where the first move is indeed owned by Environment. } 
\end{figure}
       
The library arena is infinite. Taking the tensor product of infinitely many copies of the two arenas ensures that the library arena satisfies the following property, which corresponds to the $!$ operation from linear logic: 
\begin{align}\label{eq:bang-library-arena}
\text{library arena} 
\quad \equiv \quad 
\text{(constant choice arena)} \otimes 
\text{(equality test arena)} \otimes
 \text{(library arena)}.
\end{align}
In the above, $\equiv$ refers to isomorphism of arenas, which is defined in the natural way: this is a bijection between the moves, which is consistent with the owners, register operations and plays in the expected way.  Another property is that the library arena is isomorphic to a tensor product of itself: 
\begin{align}\label{eq:library-arena-isomorphism}
\text{library arena}
\quad \equiv \quad
\text{library arena} \otimes \text{library arena}.
\end{align}


We are now ready to give the final definition of arenas for functions between linear types, which takes into account the structure of the atoms.

\begin{definition}[Arena for a function type]\label{def:arena-for-function-type} For linear types $X$ and $Y$, the arena of $X \to Y$ is 
    \begin{align*}
    \text{(library arena)} \otimes \text{(dual arena of $X$)} \otimes \text{(arena of $Y$)}.
    \end{align*}
\end{definition}

This completes the game semantics of linear types and functions between them. We do not intend to give game semantics for higher order types, such as functions on functions etc. As a result, we will only be using the dual once, namely for the arena of the input type. Also, note that the read/write operations will be used in a restricted way, as announced in Footnote~\ref{footnote:read-write}, namely that the ``read'' moves will be owned by System and the ``write'' moves will be owned by Environment.  This is because the library arena has this property, the arena for $\atoms$ has this property, and all operations on arenas that we have defined preserve this property.

\section{Further topics}
\label{sec:further-topics}

The same situation will happen  for vector spaces later in this paper. (monoidal instead of cartesian)

Along the way, we provide examples of how the category can be useful in automata theory. Our xsmain example is converting a deterministic automaton into a monoid, but another example is modelling two-way deterministic automata, and deciding their emptiness. 

An important property of our construction is that it is generic. In fact, instead of having a set that is equipped with equality only, one could apply the construction to any relational structure, e.g.~real arithmetic $(\mathbb R, +, \times, <)$, as long as the structure is given using relations and not functions. Under further assumptions on the structure, such as having a decidable first-order theory (which holds for real arithmetic) and being oligomorphic (which does not hold for real arithmetic but does hold for the rational numbers with their linear order), further benefits in the resulting single-use category can be derived, such as having an emptiness algorithm for deterministic two-way automata. 

Finally, as a minor contribution, we present an alternative solution for the problem of function spaces, which is  to use vector spaces of orbit-finite dimension. This is a minor contribution as far as the present paper is concerned, because the technical tools were developed already in~\cite{bojanczykKM21OrbitFiniteVector}, and the only contribution -- if any -- of this paper is one of perspective, namely framing it as a symmetric monoidal closed category. An advantage of the vector space category is its simplicity, and the fact that it is ``bigger'' in the following sense. The two solutions for function spaces discussed in this paper, namely the single-use solution and the vector space solution, sit on both sides of the classical category of orbit-finite sets, as witnessed by two faithful functors, one from the single-use category to the orbit-finite category, and one from the orbit-finite category to the vector space category. 
The generality of vector spaces comes at a price, though. As mentioned before, the single-use construction can be applied to any structure, and the orbit-finite benefits can be derived for all $\omega$-categorical structures (this is the standard assumption in the study of orbit-finiteness). In contrast, the vector space construction is more brittle, and it fails for certain $\omega$-categorical  structures such as the Rado graph.   Another disadvantage of the vector space category is that it is not traced with respect to the coproduct, unlike the single-use category, which precludes the applications to two-way automata.

\subparagraph{Related work: categories and $\lambda$-calculus.}

There have been several works using category theory to generalize classical operations on automata, such as the coalgebraic ``generalized powerset construction''~\cite{DBLP:journals/corr/abs-1302-1046}. The closest to the philosophy we exposed in the introduction might be the setting introduced by Colcombet and Petrişan~\cite{colcombet2020automata}, where automata in different categories are compared. Within this setting, Nguy{\~{ê}}n and Pradic have studied some properties of automata over symmetric monoidal closed categories~\cite[Sections~1.2.3~and~4.7--4.8]{titoPhD}.

The latter emerged as part of their research on ``implicit automata''~\cite{IATLC,IATLC2,titoPhD,pradic2024implicit}, which is about relating the expressive power of automata and typed $\lambda$-calculi. In~\cite{IATLC2,titoPhD}, a monoidal closed category of single-use assignments on string-valued registers is built and used to relate a register-based string transducer model to a $\lambda$-calculus with linear types. Indeed, symmetric monoidal closed categories are famous for providing denotational semantics for the linear $\lambda$-calculus. Similarly, our results here could serve to characterize the languages of words with atoms from~\cite{bojanczykstefanski2020} via some typed $\lambda$-calculus.

Conversely, our \Cref{thm:single-use-closed} might also be provable by representing single-use functions as $\lambda$-terms (or programs in some richly structured syntactic formalism) instead of strategies over games. Indeed, it is a classical fact that a simple type is inhabited by finitely many linear $\lambda$-terms up to $\beta$-conversion (when there are no primitive constants), and variations on this fact have been used in the literature to relate automata and $\lambda$-calculus~\cite{IATLC,LambdaTransducer}.



\bibliography{bib}

\appendix



\input{beyond-equality}
\input{beyond-equality-appendix}
\input{two-way-automata}
\input{two-way-appendix}
\input{vector}
\input{vector-appendix}






\end{document}
