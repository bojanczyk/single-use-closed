\newcommand{\invar}[1]{#1_{\mathrm{in}}}
\newcommand{\outvar}[1]{#1_{\mathrm{out}}}

\section{Game semantics}
\label{sec:game-semantics}

This section is devoted to the proof of Theorem~\ref{thm:single-use-closed}. To construct the function space $X \Rightarrow Y$, we use game semantics to identify a certain normal form of programs that compute single-use functions. The presentation in this section is self-contained, and does not assume any knowledge of game semantics. We base our notation on~\cite{abramsky2013semantics}.

Let us begin with a brief motivation for why game semantics will be useful.

While it is intuitively clear which functions should be allowed as single-use for simple types such as $\atoms \to 1+1$ or $\atoms \otimes \atoms \to \atoms + \atoms$, these intuitions start to falter when considering more complex types. How can one show that a function is \emph{not} single-use? If one were to use the definition of single-use functions alone, then one would need to rule out any possibility of constructing the function from the primes using the combinators, including constructions that use composition many times, and with unknown intermediate types. 

This is the reason why we consider game semantics. It will allow us to give  a more principled description of the intuition that pairs of type $X \otimes Y$ can be used on both coordinates, while pairs of type $X + Y$ can be used on a chosen coordinate only. The idea behind game semantics is to give the description in terms of an interaction between two players.  The two players are:
\begin{enumerate}
    \item System, who represents the function (we will identify with this player); and
    \item Environment, who supplies inputs and requests outputs of the function.
\end{enumerate}
One of the intuitions behind the setup is that if a type $X \& Y$ appears in the input of the function, then it is the System who can choose to use $X$ or $Y$, while if the type appears in the output, then it is the Environment who makes the choice. (In this paper, we consider functions of first-order types of the form $X \to Y$, where $X$ and $Y$ are linear types that do not use $\otimes$, and therefore there will be a clear distinction between input and output values.)
Before giving a formal definition of game semantics, we give simple example of the interaction.

\begin{example}\label{ex:amp-otimes-distr}
    Consider the two types 
    \begin{align*}
        X \otimes (Y \& Z) 
        \quad \text{and} \quad
        (X \otimes Y) \& (X \otimes Z).
    \end{align*}
    Among the prime functions in Table~\ref{fig:prime-morphisms-with-with}, we find distributivity in the direction $\rightarrow$, but not in the direction $\leftarrow$. We explain this asymmetry using the interaction between two players System and Enviroment.

    Let us first consider the interaction in the  direction $\rightarrow$. Player Environment begins be requesting an output. Since this output is of type $(X \otimes Y) \& (X \otimes Z)$, this means that Environment can choose to request either of the two types  $X \otimes Y$ and $X \otimes Z$. Suppose that Environment requests $X \otimes Y$. Now player System needs to react, and produce two elements: one of type $X$ and one of type $Y$. Both can be obtained from the input; for the second one player System can choose how to resolve the input $Y \& Z$ to get the appropriate value. 

    Consider now the interaction in the opposite direction $\leftarrow$. As we will see, player System will be unable to react to the behavior of player Environment, which will demonstrate that there is no distributivity in this direction. The problem is that player Environment can begin by requesting an element of type $X$, since the output type is $X \otimes (Y \& Z)$, while still reserving the possibility to request $Y \& Z$ in the future (because the tensor product $\otimes$ means that both output values need to be produced). To produce this element, player System will need  choose one of the two coordinates in the input type $(X \otimes Y) \& (X \otimes Z)$, and any of these two  choices will be premature, since player Environment can then request the opposite choice in the output type.  \exampleend
\end{example}

As illustrated in the above example, we will use a game to describe the possible behaviours of a function, as modelled by behaviours of player System. The game will be played in an arena, which will arise from the type of the function, and will tell us what are the possibilities for the moves of both players.  Here is the  outline the plan for the rest of this section. 
\begin{enumerate}
    \item For every two linear types $X$ and $Y$, we  define an arena, which is a data structure that describes all possible interactions between players Environment and System that can arise when running a  single-use  functions of type $X \to Y$;
    \item In each arena, we will be interested in the strategies of player System, i.e.~the ways in which System reacts to moves of Environment. We will show how such strategies can be interpreted as single-use functions: to a strategy we will assign a single-use function of type $X \to Y$ that is represented by this strategy. This mapping will be partial, i.e.~some ill-behaved strategies will not represent any functions. 
    \item We will show that the  set of strategies in an arena is  large enough to represent all single-use functions, but small enough to be orbit-finite. 
    \item We will then strengthen this: not only is the set of strategies orbit-finite, but it can be equipped with the structure of a linear type, such that both evaluation and Currying will be single-use functions.
\end{enumerate}

The arenas from the first step of the plan will  be defined in two sub-steps. We begin by defining arenas and strategies for functions that do not use the structure of the atoms, i.e. constants and equality tests. This will be a fairly generic definition, almost identical to the classical game semantics for linear logic. Then we will extend the definition to cover the extra structure. 

\subsection{Arenas and strategies without constants and equality tests}
\label{sec:arenas-without-constants-and-equality-tests}

We begin with a simpler version of the game semantics, in which the arenas and strategies will describe functions that are not allowed to perform equality tests, and are not allowed to use constants. These strategies will model functions such as the identity function $\atoms \to \atoms$, which directly passes its input to its output, but they  will not model the equality test $\atoms \otimes \atoms \to 1 + 1$, or the constant functions of type $1 \to \atoms$. The general idea is to use standard game semantics for linear logic, with an extra feature that we call \emph{register operations}. The register operations will be used to model the way in which atoms are passed from the input to output. For example, in the identity function,  Environment will  write the input atom into the register, and then player System will read the output atom from that register. The following definition of an arena is based on the definition from \cite[p.4]{abramsky2013semantics}, slightly
adapted for the context of this paper:
\begin{definition}[Arena] \label{def:arena}
    An \emph{arena} consists of:
    \begin{enumerate}
        \item A set of \emph{moves}, with each move having an assigned owner, who is either ``System'' or ``Environment'', and one of three\footnote{\label{footnote:read-write} In all arenas that we consider, the ``read'' moves will be owned by System and the ``write'' moves will be owned by Environment. Therefore, we could simplify the register operations and have just one, called ``read/write'', whose status is determined by its owner. 
        } register operations, which are ``none'', ``read'', or ``write''.
                \item A set of plays, which a set of finite sequences of moves that is closed under prefixes, and such that in every play, the owner of the first move is Environment, and then the owners alternate between the two players.
    \end{enumerate}
\end{definition}




An arena will correspond to a type. The inhabitants of that type, which will be  functions if the type is a functional type $X \to Y$, will be described by strategies in the arena. Such a strategy tells us how player System should react to the moves of player Environment. Intuitively speaking, in the case of a functional type, a strategy will say how the function reacts to requests in the output type and values in the input type. We will only be talking about strategies for player System, so from now on, all strategies will be for player System. The following definition corresponds to the definition from \cite[p.5]{abramsky2013semantics}:
%unless otherwise stated.
% In the above definition, the operations are a non-standard part of the arenas.  The idea is that the operations modify a memory store which has exactly one register, which contain a single atom or be empty.  A move that has an associated operation that is not ``none'' will be called an \emph{atom move}.


\begin{definition}[Strategy]
    A strategy  in an arena  is a subset of plays in the arena, which: 
    \begin{enumerate}
        \item is closed under prefixes;
        \item\label{item:sys-ext} if the strategy contains a play $p$ that ends with a move owned by player System, then it also contains all possible plays  in the arena that extend $p$ with one move of player Environment;
        \item\label{item:env-ext} if the strategy contains a play $p$ that ends with a move owned by player Environment, then it contains exactly one play  in the arena that extends $p$ with one move of player System;
         \item there is some $k$ such that all plays in the strategy have length at most $k$;
        \item every ``read'' move is directly preceded by a ``write'' move (in particular a play cannot begin with ``read''), and every ``write'' move is either the last move, or directly succeeded by a ``read'' move.
    \end{enumerate}
\end{definition}

Conditions \ref{item:sys-ext} and \ref{item:env-ext}, which are standard in game semantics,  guarantee that the strategy only ``ends'' when 
Environment has no moves to play.  Let us now comment on the last two conditions, which are not standard.

The fourth condition is motivated by the idea that we study ``finite'' types,  and there will be no need for unbounded computations. 

The last condition will be called the  \emph{immediate read condition}. It ensures that there is matching between ``read'' and ``write'' moves in plays that do not end with write. Since ``write'' will always be owned by Environment, the immediate read condition will ensure a matching between ``write'' and ``read'' moves.
%in the plays that do not end with a move by player Environment, and such plays will be the most important ones. 

We now show how to associate to each linear type a corresponding arena, and also how to associate an arena to a function type $X \to Y$. This definition will be compositional, i.e.~it will arise through operations on arenas that correspond to the type constructors such as $1$ or $\otimes$. The arenas that we will construct so far will not be our final proposal, since the corresponding strategies will not be able to use constants or perform equality tests. This will be fixed in Section~\ref{sec:arenas-with-constants-and-equality-tests}, where a more complex arena will be defined for function types. Before giving formal definition, we begin with a simple example of the arena for the type $\atoms \to \atoms$.
\begin{example}\label{ex:identity-function-without-equality-tests-and-constants}
    We define an arena for the type $\atoms \to \atoms$. This arena will be rather impoverished, since the  only allowed strategy in it will correspond to the identity function. However, this is consistent with the stage that we are at, where we only consider functions that do not use constants or perform equality tests; for such functions the only possibility is the identity function.

     The arena will describe the following interaction between the two players: Environment  requests an output,  then System requests an input, then Environment grants the input, and finally player System grants the output by forwarding the input grant. 
    The arena is shown in the following picture: 
    \mypic{6}
    The methodology of drawing this picture will become clearer later on, as we define operations on arenas such as $\otimes$. For the moment we describe the arena without caring that it arises as a special case of some general construction. The arena has four moves: 
    \begin{center}
        \begin{tabular}{lll}
         move & owner & register operation \\
            \hline
            request output & Environment & none \\
            request input & System & none \\
            grant input & Environment & write \\
            grant output & System & read 
        \end{tabular}    
    \end{center}
    The set of plays is defined as follows. These are all sequences that begin with a move of player Environment, alternate between players, use each move only once, and have the following condition:  ``grant output'' can only be played after ``request output'', and likewise for ``grant input'' and ``request input''.  

    A quick inspection of the above definition reveals that the arena has a unique maximal play, where the moves are played in the order from the table, and all other plays are prefixes of this maximal play. Because of the uniqueness of responses, the set of plays is also a strategy. As mentioned at the beginning of this example, the strategy describes the identity function.  \exampleend
\end{example}

We hope that the above example explains some intuitions about how arenas describe types and strategies describe functions. We now give a formal definition. As mentioned before, this definition is compositional: we define arenas for the basic types $1$ and $\atoms$, and then we define operations on arenas that correspond to the type constructors  $+$, $\&$, and $\otimes$. We begin with the basic types.


\begin{definition}[Arenas for $1$ and $\atoms$]\label{def:arenas-without-atoms-or-functions} \ 
    \begin{enumerate}
        \item     The arena for the type $1$ is empty: there are no moves and the only play is the empty sequence. 
        \item The arena for type $\atoms$ has two moves, which must be played one after the other: first player Environment makes a move called ``request'' that has no register operation, and then player System responds with  a move called ``grant'' that has register operation ``read''.
    \end{enumerate}
\end{definition}

In the above definition, we only described the behaviour of $\atoms$ when viewed as an output type. To get the input type, where the players are swapped and read is swapped with write, we will use duality, which is another operation on arenas. This operation, together with other operations that correspond to the type constructors, are defined below.   

\begin{definition}[Operations on arenas]\label{def:composition-of-arenas}
    Let  $A$ and $B$ be arenas. We define the following arenas (see also Figure~\ref{fig:arena-constructors}):
        \begin{description}
            \item[$A+B$] The moves in this arena are the disjoint union of the moves of $A$ and $B$, with inherited owners and register operations, plus three extra moves: ``ask'' owned by Environment, and ``left'', ``right'' owned by System. 
            The plays are defined as follows. Player Environment begins with  an ask move, then System responds with a left or right move, and the remaining sequence is a play in the arena $A$ or $B$, depending on whether System chose left or right. 
            \item[$A \& B$] The moves in this arena are the disjoint union of the moves of $A$ and $B$, with inherited owners and register operations, plus three extra moves: ``acknowledge'' owned by System, and ``left'', ``right'' owned by Environment. 
            The plays are defined as follows. Player Environment begins by choosing left or right, then player System responds with an acknowledge move, and the remaining sequence is a play  in the arena $A$ or $B$, depending on whether Environment chose left or right.
            (This construction differs slightly from the one from \cite[Excercise~1.10]{abramsky2013semantics} -- this is because we want to keep it analogous to the construction for $A + B$.)
            \item[$A \otimes B$] The moves in this arena are the disjoint union of the moves of $A$ and $B$, with inherited owners and register operations. A play in this arena is any shuffle of plays in the two arenas $A$ and $B$. (A shuffle of two words is any word obtained by interleaving them, e.g.~shuffles of ``abc'' and ``123'' include ``a1b23c'' and ``12ab3c'').
            By Definition~\ref{def:arenas-without-atoms-or-functions}, we require that the owners of the move alternate in the 
            interleaved sequences. (This construction is based on \cite[p.7]{abramsky2013semantics}.) 
            

            \item[$\bar A$] This is called the dual arena of $A$. The moves and plays are the same as in $A$, except the owners are swapped, and the ``read'' and ``write'' register operations are swapped.
        \end{description} 
\end{definition}

\begin{figure}
The arena $A+ B$:
            \mypic{7}
The arena $A \& B$: 
            \mypic{8}
The arena $A \otimes B$:
            \mypic{9}
    \caption{\label{fig:arena-constructors} Pictures of the operations on arenas. The picture for $\otimes$  is less useful than previous two, since the root node of the tree is not a player, but a node labelled by $\otimes$. The intuition is that the game is played in parallel on both arenas, and therefore a position in it can be visualized as a pair of positions in the two arenas.}
\end{figure}


        
Equipped with the above definitions, we  present our first attempt at assigning arenas to types. In the second item of the following definition, we use the name \emph{library-less}, because our final definition of the arena for a function type, as presented in the next section, will be equipped with an extra feature that will be called a library. 

\begin{definition} Let $X$ and $Y$ be linear types.
    \begin{itemize}
        \item The \emph{arena for  $X$} is defined by inductively applying the constructions from Definition~\ref{def:arenas-without-atoms-or-functions} and Definition~\ref{def:composition-of-arenas} according to the structure of the type.
        \item The \emph{library-less arena for $X \to Y$} is defined to be (dual of arena of $X$) $\otimes$ (arena of $Y$).
    \end{itemize}
\end{definition}

As discussed previously, our notion of arenas does not yet take into account the structure of the atoms, i.e.~the constants and equality tests. This will be fixed in the next section, by modifying the second item in the above definition. On the other hand, the arenas from that first item in the above definition, for linear types without function types, are already in their final form. 

In principle the construction from the second item in the above definition can be nested, and thus used to assign arenas to higher order types that can nest $\to$ with the other type constructors. This is how it is usually done in linear logic. However,  the construction that we will describe in the next section will  be less amenable to nesting, and will use it only  to describe functions between types that do not use $\to$.


 

\begin{example}
    The arena for the identity type $\atoms \to \atoms$ is the same as the arena from Example~\ref{ex:identity-function-without-equality-tests-and-constants}.
\end{example}





\subsection{Arenas and strategies with constants and equality tests}
\label{sec:arenas-with-constants-and-equality-tests}
In the Section~\ref{sec:arenas-without-constants-and-equality-tests}, we described arenas for functions that did not use the structure of the atoms, i.e.~constants and equality tests. We now show how these arenas can be extended to cover this structure. The general idea is to equip the arenas with an extra part, which we call the \emph{library},  that describes the allowed operations on the atoms. (The library as we present it here only contains functions for equality and constants, but in the proof of Theorem~\ref{thm:single-use-automata-relational-structures}, we can use a library that has other relations beyond equality. )



\begin{definition}[The library arena] \label{def:library-arena} The library arena and its parts are defined as follows, see Figure~\ref{fig:library-arenas} for pictures.
    \begin{enumerate}
        \item The \emph{constant choice arena} is the following arena $\atoms+1$ moves:
        first player System chooses an atom, then player Environment plays move with register operation ``write''. 
        \item The \emph{equality test arena} is an arena which the plays are as follows:
    \begin{enumerate}
        \item first player System plays a move with register operation ``read'';
        \item then player Environment plays an move with no register operation;
        \item then player System plays a move with register operation ``read'';
        \item then player Environment plays one of two moves, called $=$ and $\neq$, with no register operation.
    \end{enumerate}
    \item The \emph{library arena} is defined to be an arena that is obtained by applying $\otimes$ to infinitely many copies of the constant choice arena and infinitely many copies of the  equality test arena.
    \end{enumerate}
\end{definition}

\begin{figure}
The constant choice arena:
        \mypic{10}
The equality test arena:
    \mypic{11}
\caption{\label{fig:library-arenas} Pictures of the library arenas.  We use the convention that the register operations are in red, and the names of the moves, which have no other role than to distinguish them, are in black. 
Note that the first move in this arena is owned by System, and we assume in Definition~\ref{def:arena} that the first move is owned by Environment. This is because this arena, like all arenas in Definition~\ref{def:library-arena}, is not intended to be a stand-alone arena, but only as part of the bigger arena from Definition~\ref{def:arena-for-function-type} where the first move is indeed owned by Environment. } 
\end{figure}
       
The library arena is infinite. Taking the tensor product of infinitely many copies of the two arenas ensures that the library arena satisfies the following property, which corresponds to the $!$ operation from linear logic: 
\begin{align}\label{eq:bang-library-arena}
\text{library arena} 
\quad \equiv \quad 
\text{(constant choice arena)} \otimes 
\text{(equality test arena)} \otimes
 \text{(library arena)}.
\end{align}
In the above, $\equiv$ refers to isomorphism of arenas, which is defined in the natural way: this is a bijection between the moves, which is consistent with the owners, register operations and plays in the expected way.  Another property is that the library arena is isomorphic to a tensor product of itself: 
\begin{align}\label{eq:library-arena-isomorphism}
\text{library arena}
\quad \equiv \quad
\text{library arena} \otimes \text{library arena}.
\end{align}


We are now ready to give the final definition of arenas for functions between linear types, which takes into account the structure of the atoms.

\begin{definition}[Arena for a function type]\label{def:arena-for-function-type} For linear types $X$ and $Y$, the arena of $X \to Y$ is 
    \begin{align*}
    \text{(library arena)} \otimes \text{(dual arena of $X$)} \otimes \text{(arena of $Y$)}.
    \end{align*}
\end{definition}

This completes the game semantics of linear types and functions between them. We do not intend to give game semantics for higher order types, such as functions on functions etc. As a result, we will only be using the dual once, namely for the arena of the input type. Also, note that the read/write operations will be used in a restricted way, as announced in Footnote~\ref{footnote:read-write}, namely that the ``read'' moves will be owned by System and the ``write'' moves will be owned by Environment.  This is because the library arena has this property, the arena for $\atoms$ has this property, and all operations on arenas that we have defined preserve this property.

\subsubsection{Composition of strategies}
\label{sec:composition-of-strategies}
One of the main points about strategies in game semantics is that they can be composed.
The usual construction for the function type $X \to Y$ is to take the tensor product of the dual arena for $X$ and the arena for $Y$. 
Our construction is a bit more involved, since the arena that we use has a copy of the library arena. We now explain how to compose strategies in a way that accounts for the library arena. 

We begin by describing the usual construction for composing strategies, which we call \emph{shuffling and hiding}, see \cite[p.12]{abramsky2013semantics}, with a minor adaptation to our setting that has register operations. 

\begin{definition}[Shuffling and hiding]\label{def:shuffling-and-hiding}
    Let $A, B, C$ be arenas, and consider two strategies
    \begin{align*}
    \sigma_1 \text{ in the arena $A \otimes \bar B$}
    \qquad
    \sigma_2 \text{ in the arena $B \otimes C$}.
    \end{align*}
    The shuffling and hiding strategy for  $\sigma_1$ and $\sigma_2$, which is a strategy  in the  arena $A \otimes C$, is defined to be the set of plays    $p$  such that there exist plays $p_1 \in \sigma_1$ and  $p_2 \in \sigma_2$  with the following properties: 
\begin{itemize}
    \item the play $p$ satisfies the immediate read condition;
    \item the following two sequences of moves are equal: 
    \begin{enumerate}
        \item the subsequence of moves in $p_1$ that are from the arena $\bar B$;
        \item the subsequence of moves in $p_2$ that are from the arena $B$.
    \end{enumerate}
\end{itemize}
\end{definition}

Note that the set of moves in the arenas $\bar B$ is the same as the set of moves in the arena $B$ (the owners and register operations are changed),  and therefore the subsequences in items 1 and 2 above can be meaningfully compared.  The following lemma, whose straightforward proof is left to the reader,  shows that the above definition is well-formed.


\begin{lemma}
    The strategy described in Definition~\ref{def:shuffling-and-hiding} is a valid strategy.
\end{lemma}

% To show that this construction 
% preserves the immediate read condition, let us consider two consecutive moves 
% $m_e, m_s$ in a sequence from $\sigma;\tau$,
% such that $m_e$ is a write move by the environment, 
% and $m_s$ is the system's response, and let us show 
% that $m_s$ is a read move. Since moves $m_e$ and $m_s$ are consecuive in 
% $\sigma ; \tau$, it follows that in some sequence in $\sigma || \tau$, 
% they are separated by some moves from $B$:
% \[ \ldots m_e b_1 b_2 \ldots b_n m_s \ldots \quad \in \quad \sigma || \tau \]
% Assume (w.l.o.g.) that $m_e$ belongs to $\sigma$.
% Then, from definition of $\sigma || \tau$,
% we know that $m_e$, $b_1$ is a consecutive pair of moves in (some sequence from) $\sigma$. 
% It follows that $b_1$ is a read move in $\bar{A} \otimes B$,
% which means that $b_1$ is a write move in $\bar{B} \otimes C$. 
% By definition of $\sigma || \tau$, we know that $b_1, b_2$
% are consecutive moves in $\tau$, which means that $b_2$ is 
% a read-move in $\bar{B} \otimes C$, which in turn means that 
% it is a write-move in $\bar{A} \otimes B$. By repeating this reasoning, 
% we obtain that $b_n$ is a wite move in either $\bar{A} \otimes B$ or
% $\bar{A} \otimes B$, which means that $m_s$ is a write move from that arena.
% We can use the same reasoning to show that if $m_s$ is a read move, 
% then $m_e$ has to be a write move.  


We can now use shuffling and hiding to compose strategies in the arena for a function type that were defined in Definition~\ref{def:arena-for-function-type}.
Consider three linear types $X, Y, Z$, and two strategies, in the arenas for $X \to Y$ and $Y \to Z$, respectively.
 By unfolding the definition of arenas from Definition~\ref{def:arena-for-function-type}, these are strategies in the arenas 
\begin{align*}
\text{(library arena)} \otimes \overline{\text{arena for $X$}} \otimes \text{arena for $Y$} & \qquad \text{the arena for $X \to Y$, and}
\\
\text{(library arena)} \otimes \overline{\text{arena for $Y$}} \otimes \text{arena for $Z$} & \qquad \text{the arena for $Y \to Z$}.
\end{align*}
Using the construction from Definition~\ref{def:shuffling-and-hiding}, we can combine them into a single  strategy in 
\begin{align*}
\text{(library arena)} \otimes  \text{(library arena)}\otimes \overline{\text{arena for $X$}} \otimes \text{arena for $Z$}.
\end{align*}
Since the library arena is isomorphic to a tensor product of two copies of itself, the above strategy gives us a strategy in the arena 
\begin{align*}
    \text{(library arena)} \otimes   \overline{\text{arena for $X$}} \otimes \text{arena for $Z$} & \qquad \text{the arena for $X \to Z$.}
    \end{align*}

This strategy is defined to be the \emph{composition} of the original two  strategies. We write $\sigma; \tau$ for this composition. Thanks to \cite[Proposition~1.2]{abramsky2013semantics}, we know that the the usual
composition of library-free strategies is associative. It follows that our composition of library strategies is associative 
up to isomoprhism. 


\subsection{Strategies as single-use functions}
In this section, we explain how a strategy in a function type $X \to Y$ can be interpreted as a single-use function from the set  $\sem X$ to the set $\sem Y$. This interpretation is partial, since some strategies will be considered inconsistent, and will not represent any function. We begin with an example which explains how  a strategy might be inconsistent. 

\begin{example}[Inconsistent strategy] \label{ex:inconsistent-strategy} Consider a strategy in the arena for  $1 \to \atoms \otimes \atoms$. We would like to think of this strategy of producing a pair of atoms. 
    %  This pair of atoms can only come from the constant choice arena.  Indeed, if player Environment requests an output, then player System will need to ultimately  produce a corresponding read move (because plays in a strategy have bounded length), which will necessarily need to be fed by a write move that is in the constant choice arena (the appropriate formalizations of these notions will be given in Section~\ref{sec:some-notation-for-describing-plays}). 
     However, an inconsistent strategy for player System could use different constants from the constant choice arena  depending on the order in which Environment requests the two output atoms in $\atoms \otimes \atoms$.  For example, the output could be (John, Mark) for one order, and (Eve, Mary) for some other order.  \exampleend
\end{example}

Below, we will formalize the intuition from the above example. We begin by developing some notation for describing plays.





\subsubsection{Some notation for describing plays}
\label{sec:some-notation-for-describing-plays}
Consider a move in the arena associated to a function type $X \to Y$. There are three kinds of moves here: moves from the library, moves from $X$, and moves from $Y$. Depending on where the moves come from, we will associate to each move an \emph{origin} as follows. 
\begin{itemize}
    \item In the case of moves which come from the library, define the  {origin} to be the copy of the constant choice arena or the equality test arena from which the move is taken.
    \item   In the case of moves which come from either $X$ or $Y$, define the origin to be the corresponding node in the syntax tree of $X$ or $Y$. Here, the syntax tree of a type is defined in the obvious way, see Figure~\ref{fig:syntax-tree}.
\end{itemize}


\begin{figure}
    \mypic{12}
    \caption{\label{fig:syntax-tree} The syntax tree of the type $((\atoms +1) + 1) \otimes ((\atoms + \atoms) \& \atoms)$.}
\end{figure}


Consider a play in the arena for $X \to Y$. Define a \emph{library call} to be a subsequence of the play that is obtained by choosing some copy of the constant choice arena or the equality test arena, and then returning all moves in the play that originate from this copy. A library call will have at most two moves if it originates from some copy of the constant choice arena (we use the name \emph{constant call} for such library calls), and at most four moves if it originates from some copy of the equality test arena (we use the name \emph{equality call} for such library calls). For each constant call, there is an associated at atom, which is the first move in the call. 

Consider a read move in the play. By the immediate read condition, this move is directly preceded by a write move. The write move will either originate from a leaf labelled by $\atoms$ in  the syntax tree of the input type $X$, or it will originate from some constant call. In the latter case, it will have a corresponding atom. Therefore, to each read move in a play we can associate either some leaf labelled by $\atoms$ in the syntax tree of the input type, or some individual atom constant. The associated object will be called the \emph{read value} of the read move.

Equipped with the above notation, we are ready to define which strategies  can  be interpreted as values or functions.

\subsubsection{Strategies in $1 \to X$ as values in $\sem X$}
\label{sec:strategies-in-1-to-x-as-elements-of-sem-x}
  We begin by describing strategies which represent values in the underlying set $\sem X$ of a linear type $X$, and then we lift this interpretation to functions.  To represent such values, we  use strategies not in the arena for $X$, but in the arena for $1 \to X$. This is because the second arena contains the library, which is needed to  produce  atom constants.

  Let $X$ be a linear type, and consider a strategy $\sigma$ in the arena for $1 \to X$. 
  In order to represent some value, this strategy must satisfy certain conditions that avoid the bad behaviour  from Example~\ref{ex:inconsistent-strategy}.   
  


\begin{definition}[Strategy that represents a value]\label{def:consistency}
    Let $X$ be a linear type and consider a  strategy in  the arena for $1 \to X$. We say that the strategy uses a node from the syntax tree of $X$ if at least one play in the strategy uses a move that originates from this node. We say that the  strategy    \emph{represents a value} if it satisfies the following conditions: 
    \begin{enumerate}
        \item Consider a node in  the syntax tree of $X$ that is labelled by co-product $+$. Then at most one child of this node is  used by the strategy. 
        \item Consider a node  in the syntax tree of $X$ that  is labelled by $\atoms$. Then there is some atom $a$ such that for every play in the strategy, if the play contains a read move that originates from the node, then the read value of this move is $a$. 
    \end{enumerate}
\end{definition}

For a strategy that satisfies the two conditions in the above definition, we can also define the value $x \in \sem X$ that it represents.  This is done as follows.  For every node  in the syntax tree  of $X$ which is used by the strategy, we assign a value, which is called the value of the strategy at the node. This value at a node is in the set $\sem Y$, where $Y$ is the linear type that corresponds to the subtree of the node.  The definition of this value at a given node  is defined using a straightforward induction on the size of its subtree: 
\begin{enumerate}
    \item the value at a leaf labelled by $1$ is the unique element of $\sem 1$;
    \item the value at a leaf labelled by $\atoms$ is the atom from the second item in Definition~\ref{def:consistency};
    \item the value at a node labelled by $\otimes$ or $\&$ is the pair of values at the children;
    \item the value at a node labelled by $+$ is the value at  the unique child in the first item in Definition~\ref{def:consistency}.
\end{enumerate}
The above definition is well-formed, since one can easily see from the definition of strategies that if a node labelled by $+$ is used by the strategy, then at least one of its children is used, and if a node labelled by $\otimes$ or $\&$ is used, then both of its children are used. Finally, the value represented by a strategy is defined to be the value that is represented at the root node of the syntax tree. 

One can easily see that every value in the set $\sem X$ is represented by at least one strategy. This will also follow from a more general result, Lemma~\ref{lem:all-functions-represented} below.

\subsubsection{Strategies in $X \to Y$ as single-use functions}
We now move to the main point of this section, which is to show how to interpret a strategy in the arena for $X \to Y$ as a single-use function of type $X \to Y$. This is done by using the definition from for values in the previous section, and then lifting it to functions by using composition of strategies that was defined in Section~\ref{sec:composition-of-strategies}.


\begin{definition}\label{def:strategy-as-single-use-function}
    Let $X$ and $Y$ be linear types, and let $\sigma$ be a strategy in the arena $X \to Y$. We say that $\sigma$ \emph{represents} a function  
    \begin{align*}
    f : \sem{X} \to \sem{Y}
    \end{align*}
    if for every $x \in \sem X$, if  $x$ is the value  represented by some strategy $\tau$ in the arena for $1 \to X$, then the composition strategy $\tau;\sigma$ in the arena for $1 \to Y$ represents a value, and this value is equal to $f(x)$.
%     This is illustrated in the following diagram:
%     \[
% \begin{tikzcd}
%     [column sep=4cm]
% \text{value consistent strategies in the arena for $1 \to X$}
%  \arrow[r, "\text{represented value}"] \arrow[d, "\tau \mapsto \sigma;\tau"' ]  &
%  \sem X 
%  \ar[d,"f"]\\
% \text{value consistent strategies in the arena for $1 \to Y$"} 
% \ar[r,"\text{represented value}"'] & 
% \sem Y
% \end{tikzcd}
% \]
\end{definition}

Since each strategy in $1 \to X$ or $1 \to Y$ represents at most one value, it follows that a strategy can represent at most one function. This function is called the \emph{function represented by the strategy}.  We are now ready to state the main result of this section, which is that every single-use function is represented by at least one strategy.
\begin{lemma}\label{lem:all-functions-represented}
    Let $X$ and $Y$ be linear types, then every single-use function of type $X \to Y$ is represented by at least one strategy. 
    % \begin{itemize}
    %     \item \emph{Soundness.} Every function represented by a strategy in the arena for $X \to Y$ is single-use.
    %     \item \emph{Completeness.} Every single-use function of type $X \to Y$ is represented by at least one strategy.
    % \end{itemize}
\end{lemma}
\begin{proof}
    It suffices to show that all single-use prime functions can be represented as strategies,
    and  to lift the combinators $\circ$, $\otimes$, $\times$, $\&$ from functions to 
    strategies in a way that preserves the semantics. Let us start with the combinators:
    \begin{description}
        \item[$f; g$] We compose the corresponding strategies. The correctness of this construction is witnessed by the following claim. 
\begin{claim}\label{claim:composition-of-strategies-and-functions}    Let $X, Y, Z$ be linear types, and 
    let $\sigma_1$ and $\sigma_2$ be strategies in the arenas for $X \to Y$ and $Y \to Z$, respectively. If both of these strategies represent functions, then  $\sigma_1;\sigma_2$ also represents a function, and this function is equal to the composition of the functions represented by $\sigma_1$ and $\sigma_2$.
\end{claim}
\begin{proof}
    Let $\tau$ be some value consistent strategy in the arena for $1 \to X$. By associativity of strategy composition, we know that the strategies 
    \begin{align*}
    \tau;(\sigma_1;\sigma_2) \quad \text{and} \quad (\tau;\sigma_1);\sigma_2
    \end{align*}
    are equal, up to an isomorphism of the library arena. Since such an isomorphism does not affect value consistency or the represented value, either both or none are value consistent, and if they are value consistent, then they represent the same value. The right strategy is value consistent by the assumption of the lemma, and therefore the same is true for the left strategy, and the represented values are equal.
\end{proof}


        \item[$f_1 + f_2$] Suppose that functions $f_1$ and $f_2$ are represented by strategies $\sigma_1$ and $\sigma_2$. We join these two strategies into a new strategy $\sigma$ as follows.  Player Environment begins, and the only move available is to ``ask'' for one of the two disjuncts of the output type, which is the co-product of the output types of $f_1$ and $f_2$. Player System responds with a corresponding question on the input type. The only choice for player Environment is to select either ``left'' or ``right'' in the input type. Player System forwards this choice to the output type, and then uses the corresponding strategy.  Every play in this strategy has the following form: it begins with four moves that select a disjunct, and then it continues with a play in the strategy $\sigma_1$ or $\sigma_2$, depending on  the appropriate disjunct. From this property, one can show that the strategy represents the function $f_1 + f_2$.
        \item[$f_1 \& f_2$]  The construction is defined analogously to the one for $f_1 + f_2$.
        \item[$f_1 \otimes f_2$] Again, we use an analogous construction, in which player System plays in parallel the two strategies representing the functions $f_1$ and $f_2$. The corresponding property, which ensures that the strategy represents the function $f_1 \otimes f_2$, is that each play can be split into a shuffle of two plays, one for the strategy representing $f_1$ and one for the strategy representing $f_2$.
    \end{description}
    Let us now deal with prime functions. For the sake of brevity we only show the strategies for selected prime functions. The remaining prime functions can be implemented without using  the library, and are well known strategies corresponding to tautologies of affine logic:
    \begin{description}
        \item[Equality test of type $\atoms \otimes \atoms \to 1 + 1$]:
        For this function, System uses the library function for comparing atoms 
        and returns the result. The library is designed to implement this function, so the construction is straightforward, but we describe it here for the convenience of the reader:
\begin{itemize}
    \item Environment begins by  playing ``ask'' in $1+1$, this is the only choice
    \item System  plays  ``request'' in the left $\atoms$.
    \item Environment replies with ``grant'' which is a write move, this is the only choice.
    \item System plays the read move in atoms equality library function.
    \item Environment acknowledges, this is the only choice.
    \item System plays  ``request'' in the right $\atoms$.
    \item Environment plays ``grant'', this is the only choice.
    \item System plays the read move in the atoms equality function.
    \item Environment replies with either $=$ or $\neq$ in the library, these are the only choices.
    \item System forwards this choice to the output type.
\end{itemize}
        

        \item[Constant function of type $1 \to \atoms$] As in the previous item, this function is implemented by using the library, in this case the constant choice part of the library. 

        \item[Projection of type $ X \otimes Y \to X$] System uses the  shuffling and hiding strategy that was described in Section~\ref{sec:composition-of-strategies}. 

        \item[Distributivity  of type $X \otimes (Y \& Z) \to (X \otimes Y) \& (X \otimes Z)$] The  strategy from Example~\ref{ex:amp-otimes-distr}.  
        % The environment 
        % starts by either playing ``left'' or ``right'' in $(X \otimes Y) \& (X \otimes Z)$, 
        % we respond with the same move in $(Y \& Z)$. The environment has to play ``acknowledge'' 
        % in $(Y \& Z)$, after which we play acknowledge. This leaves us in a state that is either 
        % equivalent to $X \otimes Y \to X \times Y$ or  $X \otimes Z \to X \times Z$. 
        % In both cases we play according to the shuffling and hiding strategy. 
    \end{description}
\end{proof}
One could also show that all represented functions are single-use. We omit this proof, since we will prove a stronger result in the next section. 

\subsection{The set of strategies as a linear type}
The purpose of this section is to show that the set of strategies in an arena for a function type $X \to Y$ can be described using some linear type, and furthermore the relevant operations on strategies, such as application and Currying, can be performed in a single-use way.

Before we do this we introudce the idea of a \emph{partially applied arena}.
Let $A$ be an arena, and $m$ a move. We define the partially applied arena ${m^{-1}}A$ 
to be set of sequences that follow $m$ in $A$, i.e:
\[m^{-1}A = \{s \ | \ ms \in A \}.\]
The partially applied arena also remembers two bits of information about its context: (a) wheather the current move belongs to the Environment or to the System
(b) wheter the previous move was a write move (so that we know if the next move has to be a write move). We finish our discussion with the observation 
that if moves $a, b$ belong to $\atoms$ (i.e. they are constant requests from the library), then $a^{-1}A = b^{-1}A$. 
For this reason we define the notation $\atoms^{-1}A$ for partially applying any of the atomic moves. 


We are now ready the type for storing $k$-bounded strategies.  The following definition inputs an explicit bound $k$ for the length of the plays, but later on in this section will show that such a bound can be derived from the types by using an analysis of strategies.
\begin{definition}
    For a (partially applied) arena $A$, we define the type $\Strat(A, k)$ of $k$-bounded strategies on $A$ using the following induction:
\begin{itemize}
    \item $k=0$. This type is $1$ if the Environment owns $A$ and has no moves to play. Otherwise, this type is $\emptyset$.
          (Observe that $\emptyset$ is not a valid type in our language, so in the inductive step we are going to handle it explicitly --
          the main idea is that if its used with $+$ then it is going to be ignored,
          and if it is used with $\&$ then the entire type is going to be $\emptyset$.) 
    \item $k + 1$. This type is defined differently, depending on whether Environment or System owns $A$.
    \begin{itemize}
        \item Environment owns $A$. Let $m_1,\ldots,m_n$ be the set of possible first moves. (This set is finite.) The type is defined to be 
        \begin{align*}
            \Strat(m_1^{-1}A, k) \quad \&\  \cdots\  \& \quad  \Strat(m_n^{-1}A, k).
        \end{align*}
        Let us briefly mention how to handle edge cases: If at least one $\Strat(m_n^{-1}A, k)$ is equal to $\varnothing$, then 
        the entire type is equal to $\varnothing$. If there are no valid moves $m_i$, then the entire type is equal to $1$. 
        \item System owns $A$. Now we also consider two options, depending on whether the previous move by Environment was a write move. 
               If it was a write move, then let $m_1, \ldots, m_n$ be the current set of possible read moves that are not the first moves in any library 
               component. (This set is finite). Then our type is defined as follows:
               \begin{align*}
                \Strat(m_1^{-1}A, k) + \cdots + \Strat(m_n^{-1}A, k) + \underbrace{\Strat({\text{eq}}^{-1}A, k)}_{\substack{\textrm{Start a new call to}\\
                \textrm{atoms comparing}\\
                \textrm{library function}}}.
               \end{align*}
               The other case is when the previous move was not write. Then let $m_1, \ldots, m_n$ be the set of available moves that are not read moves. 
               (This set is finite again.) The strategy type is defined as: 
               \begin{align*}
                \Strat(m_1^{-1}A, k) + \ldots + \Strat(m_n^{-1}A, k) + \underbrace{\atoms \otimes \Strat(\atoms^{-1}A, k)}_{\substack{\textrm{Start a new call to}\\
                \textrm{atomic constants}\\
                \textrm{library function}}}.
               \end{align*}
               Again, let us mention the edge cases: If some $\Strat(m^{-1}A, k)$ is empty (including the cases where $m$ is the new library move, i.e. $\atoms$ or $\text{eq}$)
               then we simply skip it. If all $\Strat(m_i^{-1}A, k)$ are empty, then the entire type is empty.
    \end{itemize}
\end{itemize}
\end{definition}
The intuition behind this definition, which was already discussed in the main body of the paper, is as follows. If the current move belongs to Environment, then the strategy 
for System needs to be prepared for every possible move by the environment. However, eventually Environment 
will play only one move, so only one of those paths will materialize. This behaviour corresponds exactly to the connective $\&$, and is the reason why  it is used to make our single-use category symmetric monoidal closed.
When the system is about to move, then it needs to pick one of the possible moves. This corresponds to the behaviour of the connective $+$.

In order to find a linear type that could represent all functions in $X \to Y$, we are going to show 
that for every linear types $X$ and $Y$ there is a bound $k$, such that every single use function $f : X \to Y$
can be represented as a $k$-bounded strategy, i.e. as $\sigma \in \Strat(X \to Y, k)$. Before we do this, 
let us point out some potential problems. 

The main problem is that (as long as $Y \not \approx 1$), there is no universal bound $k$ for strategies in the arena for $X \to Y$
(even though each strategy is bounded by some $k$). The  reason is that System might ask an arbitrary number of irrelevant questions, 
i.e. questions that use the equality test on two constants. Interestingly, the irrelevant questions might appear as a result of compositions of strategies:
% The following lemma shows that if irrelevant questions are disallowed, then plays have length bounded by some constant that depends only on the types involved. This will be one of the useful properties of such strategies, since it will allow us to represent them using a finite linear type.
% \begin{lemma}\label{lem:no-irrelevant-questions-are-bounded}
%     For every linear types $X$ and $Y$ there is some $k$ such that if a strategy in the arena for $X \to Y$ does not ask irrelevant questions, then all plays in the strategy have length at most $k$.
% \end{lemma}
\begin{example}[Irrelevant questions from composition]\label{ex:irrelevant-questions-from-composition}
    Consider the  following two functions: 
    \begin{enumerate}
        \item the function of type  $1 \to \atoms \otimes \atoms$ that outputs the pair (Mark, John) for its unique input;
        \item the equality test of type $\atoms \otimes \atoms \to 1 + 1$.
    \end{enumerate}
    Like all single-use functions, the above two functions have natural representations that do not ask irrelevant questions.
    However, if we apply the composition construction from Section~\ref{sec:composition-of-strategies} to these two strategies, we will get a strategy that asks the irrelevant question of whether Mark and John are equal. \exampleend
\end{example}

The idea of irrelevant questions captures the intuition of why strategies might be arbitrarily long, but it is not the only reason for this. Another reason is that System might use constants to start an arbitrary number of parallel calls to the equality test library function, 
never completing any of them. This is why we introduce the following definition:
\begin{definition}[Well-formed strategy]
    We say that a strategy is \emph{well-formed} if it never starts a new call to the equality test library function, by passing a constant as its first argument.
\end{definition}

\noindent
Well-formed strategies are bounded, as shown by the following lemma:
\begin{lemma}\label{lem:well-formed-bounded}
    For every linear types $X$ and $Y$ there is a universal bound $k$, such that all well-formed strategies in $X \to Y$ are bounded by $k$. 
\end{lemma}
\begin{proof}
    We start by defining the dimension of a type to be the maximal number of $\atoms$ that the type can store at the same time. This is defined inductively, 
    where $\dim(1) = 0$, $\dim(\atoms) = 1$, and the dimension of complex types is computed as follows:
    \[ \begin{tabular}{ccc}
        $\dim(X + Y) = \dim(X \& Y) = \max(\dim(X), \dim(Y))$ & and & $\dim(X \otimes Y) = \dim(X) + \dim(Y)$
    \end{tabular}
    \]
    This is because in case of $X \otimes Y$ both $X$ and $Y$ exist at the same times, and in case of $X + Y$ and $X \& Y$ the values $X$ or $Y$
    only one of them can materialize. 

    The key observation is that in a well-formed strategy, every constant granted by the environment is either compared with an atom from input, 
    or moved to the output. It follows that in a well-formed strategy, the system can ask for at most $\dim(X) + \dim(Y)$ constants
    (because, due to the immediate read rule, each constant has to be used). It is now not hard to see that the lengths of well-formed strategies 
    in $X \to Y$ are bounded by some $k$ that depends only on the types $X$ and $Y$.
\end{proof}

As illustrated by Example~\ref{ex:irrelevant-questions-from-composition}, well-formedness is not preserved under composition of strategies. 
For this reason, we need that every  strategy that is not well-formed  can be turned into a well-formed one in a way that preserves its semantics (later we will also 
show that this can be done in a single-use way). Before we do this, we would like to assume a weaker property of the possibly non-well-formed strategy 
of the input:
\begin{definition}[Read-consistent strategy]
    A strategy is called \emph{read-consistent} if, after requesting an atomic value from the environment, it uses the same move 
    to consume this value in all of the branches. This request can be made either through a move in the constant
    library component or a "request" move in an $\atoms$ on the input. Here is a visual representation:
    \picc{read-consistant-ex} 
    (The squiggly lines represent more than one move). Here the system requests the atom John from the environment. 
    Enviroment might respond immediately with write (as in the bottom branch) or it might wait some time 
    (as in the middle or top branch). The read-consistency propery requires that the system uses the same move to read 
    the value John in all of those branches (i.e. $M_1 = M_2 = M_3$). 
\end{definition}

The advantage of read-consistency over well-formedness is that it is preserved under compositions of strategies. 
(One can show this directly from \ref{def:shuffling-and-hiding} -- the key idea is to compare the system's response to the immediate write,
with the system's response to every other possible write). Using this observation, we can show that read-consitent strategies are complete:
\begin{lemma}\label{lem:all-read-consistent}
    For every single use function $f : X \to Y$, there is a read-consistent strategy in the arena $X \to Y$ that represents it. 
\end{lemma}
\begin{proof}
    The proof is analogous to the proof of Lemma~\ref{lem:su-strategies-complete}. As well-formedness is preserved
    under the combinators $\circ$, $\otimes$, $\&$, $+$. (The proof for $\otimes$, $\&$, and $+$ is immediate.)
    Moreover it is not hard to see that all prime functions can be realized by read-consisten strategies. 
\end{proof}

Next, let us show that every read-consistent strategy can be made well-formed in a way that preserves its semantics
(thus proving completeness of well-formed strategies). 
\begin{lemma}\label{lem:all-well-formed}
    For every read-consistent strategy $\sigma$ in the arena for $X \to Y$,
    there is a well-formed strategy $\sigma'$ in the same arena that represents the same function as $\sigma$.
\end{lemma}
\begin{proof}
    Consider a system's request for a constant, in some branche of $\sigma$. 
    We say that this request is \emph{offending} if the system's intention (according to read-consistenty) is to use
    the constant to start a new call to the equality test library function.
    Let us now show how to remove an offending request from a strategy in a way that preserves the strategy's semantics
    (without introducing any new offending requests). This is enough to finish the proof of the lemma,
    because we can repeat this construction for all offending moves. (And thanks to read-consistency, we know that 
    if a strategy contains no offending moves, then it is well-formed.)

    Let ``request Alice'' be the offending move. Here is how we remove it:
    \custompicc{offending-elim-1}{0.4}
    Where $T'$ is the strategy obtained by inlining the atom Alice in $T$. 
    Specifically we need to remove all moves that are used to complete the 
    equality test library function that was initiated with the atom Alice.
    In order to do this, we identify all atom requests by the system, 
    whose value the system intends to compare with Alice.
    (In each of $T$ there can be at most one such move.)
    There could be of two types, the first one is a request for another 
    constant. We deal with it in the following way:
    We ask what would happen if the environment immedately returned a write move. 
    In this case, we know that the system would respond with the completion of the equality test. 
    Then, we conider the case when the environment immedately returns the result of the comparision -- 
    either $=$ or $\neq$ and replace the entire subtree with the appropriate move. 
    For example, we replace the following subtree with $T_{\neq}$:
    \custompicc{atom-inline}{0.55}
    In this case, we look at the entire subtree and replace each completion to equality call 
    with a single-move ``read and compare with Alice'', which represents a new fast-track 
    call to the equality test library function, that reads an atom and compares it with a constant
    (we will show how to get rid of this in the next paragraph).
    \custompicc{input-constant-inline}{0.55}
    This leaves us with showing how to get rid of the ``read and compare with Alice'' move. 
    We replace each such move with a usual eqality test initialization (a read move). 
    Then, as long as the enviroment does not play the `acknowledge' move from the equality test, 
    we play as in the original stategy. As soon as the enviroment plays `acknowledge', 
    we play ``request Alice'' to the constant library component. Then, until the environment 
    plays ``write Alice'', we continue to play as in the original strategy. Once the environment
    plays ``write Alice'', we play the ``complete equality test'' move, and then we continue 
    to play according to the original strategy. (This is possible, because the responses to 
    to ``complete equality test'', are the same as the responses to ``read and compare with Alice''). 
    Here is a picture:
    \picc{elimnate-fast-track}
\end{proof}
By Lemmas~\ref{lem:all-well-formed}~and~\ref{lem:well-formed-bounded} we know that every function $X \to Y$ 
can be represented by a srategy bounded by $k$ that depends only on $X$ and $Y$. Thanks to this observation 
we can define the exponent type. 
\begin{definition}
    We define $X \Rightarrow Y$ to be equal to $\Strat(X \to Y, k)$, where $k$ is the bound from Lemma~\ref{lem:well-formed-bounded}.
\end{definition}

Before we show, how to implement $\text{eval}$ and $\Lambda(f)$ functions, 
let us introduce first, a couple of auxiliary functions.
Let us fist show how to evaluate values:
\begin{lemma}
    For every linear $X$, there is a single-use function that 
    computes the value of a (see Section~\ref{sec:strategies-in-1-to-x-as-elements-of-sem-x}):
    \[\text{val}: (1 \Rightarrow X) \to X\]
\end{lemma}
\begin{proof}
    The function is straightforward.
\end{proof}

Next, we show that we can compose strategies in a single-use way:
\begin{lemma}
    Let $X \Rightarrow Y$ and $Y \Rightarrow Z$ be linear types, then there is a single use function:
    \[\text{compose} : (X \Rightarrow Y) \otimes (Y \Rightarrow Z) \to (X \Rightarrow Z)\]
    such that if $\sigma_1$ and $\sigma_2$ are strategies that represent functions $f_1$ and $f_2$ respectively,
    then $\text{compose}(\sigma_1, \sigma_2)$ represents the composition of $f_1$ and $f_2$.
\end{lemma}
\begin{proof}
    The proof has two steps:
    \begin{itemize}
        \item First, we show that for every $k, l$ there is a function
              $\Strat(X \to Y, k) \otimes \Strat(Y \to Z, k) \to \Strat(X \to Z, k + l)$, 
              that computes the composition of the strategies (according to the \ref{def:shuffling-and-hiding}). 
              This function can be implemented (by induction on $k + l$) by simulating the two strategies 
              and passing arround the moves in $Y$. The construction will turn out to be single-use 
              thanks to that the hiding operation is an injection on 
              the shuffled strings see \cite[Covering Lemma]{abramsky2013semantics}.
        \item Next we show that for every $l$ there is a single-use function 
              $\Strat(X \to Y, l) \to \Strat(X \to Y, k)$, where $k$ is the 
              constant from Lemma~\ref{lem:well-formed-bounded}.
              The function works by removing the offending requests from the 
              strategy, as described in the proof of Lemma~\ref{lem:all-well-formed}. The key observation that makes this construction single-use is that we can use the 
              distributivities of $+$ and $\&$ to push atoms from the node 
              of a tree to all of its children:
              \[
                \begin{tabular}{ccc}
                    $ \atoms \otimes (T_1 \& \ldots \& T_n) \to \atoms \otimes T_1 \& \ldots \& \atoms \otimes T_n$ & and &
                    $ \atoms \otimes (T_1 +  \ldots + T_n) \to \atoms \otimes T_1 + \ldots + \atoms \otimes T_n$
                \end{tabular}
              \]
    \end{itemize}
\end{proof}

The final component is the function that transforms values to strategies: 
\begin{lemma}
    There is a function $\text{toStrategy} : X \to (1 \Rightarrow X)$, 
    that returns a strategy whose semantics is equal to its input.
 \end{lemma}
\begin{proof}
    The function returns a straightforward strategy of the system. 
\end{proof}

We are now ready to define Currying and evaluation, and thus  complete the proof of Theorem~\ref{thm:single-use-closed}. 
Consider 
\begin{align*}
\text{eval} : X \otimes (X \Rightarrow Y) \to Y
\end{align*}
works as follows. We first transform the input into the type
\begin{align*}
(1 \Rightarrow X) \otimes (X \Rightarrow Y) 
\end{align*}
using the function $\text{toStrategy}$. Then we apply the function $\text{compose}$, and finally we use the function $\text{val}$ to get the result.

Now we define Currying. Consider a single-use function
\begin{align*}
f : Z \otimes X \to Y.
\end{align*}
Its Currying is defined as follows. First, we add a representation of $f$ to the input, giving a value in 
\begin{align*}
Z \otimes (Z \otimes X \Rightarrow Y).
\end{align*}
Then we transform the $Z$ into type $1 \Rightarrow Z$ using toStrategy, giving a result in type 
\begin{align*}
(1 \Rightarrow Z) \otimes (Z \otimes X \Rightarrow Y).
\end{align*}
We now transform, using a copying strategy, the first argument into type $X \otimes (X \Rightarrow Z)$, giving a result in type
\begin{align*}
(X \otimes (X \Rightarrow Z))  \otimes (Z \otimes X \Rightarrow Y).
\end{align*}
Finally, we use the function $\text{compose}$ to get the desired result.  The properties of the underlying functions ensures that Currying is consistent with evaluation, as required in Theorem~\ref{thm:single-use-closed}.




